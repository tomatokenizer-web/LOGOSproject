# 제15부: 설정 및 빌드 (Configuration & Build)

이 문서는 LOGOS 프로젝트의 설정 파일과 빌드 도구에 대한 종합적인 설명서입니다. 각 섹션은 개별 설정 파일의 목적, 구조, 그리고 시스템 내에서의 역할을 설명합니다.

---

## 1. Prisma 데이터베이스 시드 스크립트 (Prisma Database Seed Script)

> **최종 업데이트**: 2026-01-04
> **코드 위치**: `prisma/seed.ts`
> **상태**: 활성
> **실행 명령어**: `npm run db:seed`

---

### 컨텍스트 및 목적 (Context & Purpose)

이 시드 스크립트(seed script)는 **완전한 사용자 학습 여정을 나타내는 현실적인 테스트 데이터로 LOGOS 데이터베이스를 초기화(bootstrap)** 하기 위해 존재합니다. 개발이나 테스트 중에 빈 데이터베이스로 시작하는 대신, 이 스크립트는 시스템의 모든 주요 데이터 관계를 실행하는 일관된 데이터셋을 생성합니다.

**비즈니스 요구사항**: 개발자와 테스터는 다음을 위해 작동하는 데이터셋이 필요합니다:
- UI가 학습 콘텐츠를 올바르게 표시하는지 확인
- 현실적인 데이터로 적응형 학습 알고리즘(IRT, FSRS, PMI) 테스트
- UI를 통해 수동으로 테스트 레코드를 생성하지 않고 문제 디버깅
- 이해관계자에게 애플리케이션 시연

**페르소나(The Persona)**: 시드 데이터는 특정하고 현실적인 사용자 프로필을 나타냅니다: **CELBAN 시험을 준비하는 브라질 간호사**. CELBAN(Canadian English Language Benchmark Assessment for Nurses, 캐나다 간호사 영어 능력 평가 시험)은 임의로 선택된 것이 아닙니다 - 이는 LOGOS의 주요 타겟 시장인 영어권 국가에서 실무를 위해 도메인 특화 언어 자격증이 필요한 의료 전문가를 대표합니다.

**사용 시점**:
- 초기 개발 설정 시 (`npm run db:seed`)
- 데이터를 리셋하는 데이터베이스 마이그레이션 후
- 디버깅 중 알려진 정상 상태로 리셋할 때
- 통합 테스트를 위한 CI/CD 파이프라인에서

---

### 생성되는 데이터 구조 (Data Structures Created)

#### 1. 테스트 사용자 (브라질 간호사 프로필)

```
id: 'test-user-1'
nativeLanguage: 'pt-BR' (Brazilian Portuguese)
targetLanguage: 'en-US' (American English)
thetaGlobal: 0 (starting proficiency estimate)
theta[Phonology|Morphology|Lexical|Syntactic|Pragmatic]: 0
```

**이 값들을 선택한 이유:**
- **pt-BR에서 en-US**: 이 언어 쌍은 발음(포르투갈어는 다른 모음 소리를 가짐), 형태론(다른 동사 활용 체계), 화용론(문화적 의사소통 규범)에서 상당한 도전을 나타냅니다
- **Theta = 0**: IRT(Item Response Theory, 문항반응이론) 척도는 0을 중심으로 하며, 이는 평균 능력을 나타냅니다. 새 사용자는 평가를 통해 실제 능력 추정치가 정제될 때까지 모집단 평균에서 시작합니다

#### 2. CELBAN 목표 명세 (CELBAN Goal Specification)

```
id: 'celban-goal-1'
domain: 'medical'
modality: ['reading', 'listening']
genre: 'professional'
purpose: 'certification'
benchmark: 'CELBAN'
deadline: 120 days from now (4 months)
completionPercent: 0
isActive: true
```

**왜 CELBAN인가?**
- **CELBAN**(Canadian English Language Benchmark Assessment for Nurses, 캐나다 간호사 영어 능력 평가 시험)은 국제적으로 교육받은 간호사가 캐나다에서 일하기 위해 통과해야 하는 표준화된 시험입니다
- 의료 맥락에서의 언어 능력을 테스트합니다: 환자 차트 이해, 의료팀과의 의사소통, 환자에게 절차 설명
- 4개월 기한은 이 자격증을 준비하는 동기 부여된 학습자에게 현실적입니다

#### 3. 의료 어휘 (20개 언어 객체)

이 스크립트는 각각 **5요소 특성 벡터(five-element feature vector)** 를 가진 20개의 신중하게 선별된 의료 용어를 생성합니다:

| 특성 | 설명 | 범위 | 예시 (auscultate) |
|---------|-------------|-------|---------------------|
| **frequency** | 의료 영어에서 얼마나 흔한가 | 0-1 | 0.35 (희귀) |
| **relationalDensity** | 단어 네트워크에서의 허브 점수 | 0-1 | 0.41 (보통) |
| **contextualContribution** | 도메인 특수성 | 0-1 | 0.88 (매우 의료적) |
| **irtDifficulty** | 심리측정적 난이도 | -2 ~ +2 | 0.9 (도전적) |
| **definition** | 평이한 영어 의미 | 텍스트 | "청진기로 체내 소리를 듣는 것" |

**어휘 선정 근거:**

20개 용어는 난이도 구배를 포괄합니다:

**쉬운 용어 (음수 난이도):**
- *symptom* (-0.7): 높은 빈도, 일상 언어에서 흔함
- *monitor* (-0.8): 이중 용도 단어, 익숙한 맥락
- *vital signs* (-0.6): 복합 용어지만 매우 빈번함

**중간 용어 (난이도 0 근처):**
- *diagnosis* (-0.4): 흔하지만 약간 기술적
- *acute* (0.0): 의료적 의미가 일상적 사용과 다름
- *prognosis* (0.2): 덜 흔하지만 맥락에서 추측 가능

**도전적 용어 (양수 난이도):**
- *auscultate* (0.9): 희귀, 라틴어 유래, 기술적 절차
- *anaphylaxis* (1.2): 낮은 빈도, 그리스어 어근, 알아야 할 중요 용어
- *contraindication* (0.8): 추상적 개념, 복합어

**계산된 우선순위 공식:**
```
priority = frequency * relationalDensity * contextualContribution
```
이 곱셈 공식은 고우선순위 단어가 흔하면서 잘 연결되어 있고 도메인 특화된 단어임을 보장합니다.

#### 4. 숙달 상태 (20개 레코드)

각 어휘 항목은 초기 숙달 상태를 받습니다:

```
stage: 0 (Unknown - never encountered)
fsrsDifficulty: 5 (neutral starting difficulty on FSRS 1-10 scale)
fsrsStability: 0 (no memory strength yet)
fsrsReps: 0 (no reviews completed)
fsrsLapses: 0 (no forgotten-then-relearned cycles)
fsrsState: 'new' (never scheduled)
cueFreeAccuracy: 0 (no cue-free responses yet)
cueAssistedAccuracy: 0 (no cue-assisted responses yet)
exposureCount: 0 (never seen)
priority: [copied from language object]
```

**왜 0으로 초기화하는가?**

이것은 이 항목들과 전혀 상호작용한 적이 없는 완전히 새로운 학습자를 나타냅니다. FSRS 알고리즘은 첫 번째 복습 후 기억 강도 추적을 시작합니다. 단계 전환(0→1→2→3→4)은 학습자가 점진적인 숙달을 보여줄 때 발생합니다.

#### 5. 연어 (9개 단어 쌍과 PMI 점수)

**연어(Collocations)** 는 우연보다 더 자주 함께 나타나는 단어 조합입니다. 시드는 9개의 단어 쌍을 생성합니다:

| 단어 1 | 단어 2 | PMI | 동시출현 | 평이한 설명 |
|--------|--------|-----|---------------|---------------|
| vital | signs | 4.2 | 3,500 | 의료 텍스트에서 거의 따로 나타나지 않음 |
| blood | pressure | 3.9 | 2,800 | 고정된 의료 구문 |
| heart | rate | 3.7 | 2,400 | 표준 바이탈 사인 용어 |
| administer | medication | 2.8 | 1,250 | 흔한 동사-명사 짝 |
| chronic | pain | 2.6 | 1,800 | 빈번한 임상 설명어 |

**PMI(Pointwise Mutual Information, 점별 상호정보량)** 는 두 단어가 독립적으로 나타나는 것보다 얼마나 더 자주 함께 나타나는지를 정량화합니다:
- PMI > 3: 거의 고정된 구문 (vital signs, blood pressure)
- PMI 2-3: 강한 연어 (administer medication)
- PMI < 2: 약한 연관성

**학습에 이것이 중요한 이유:**

학습자가 "vital"은 알지만 "signs"는 모를 때, LOGOS는:
1. "signs"를 곧 배워야 한다고 예측할 수 있음 (높은 PMI는 공동 학습 이점을 제안)
2. 연어를 맥락에서 제시하는 과제 생성
3. 생산적 지식 테스트: "구문을 완성하세요: vital ____"

**NPMI 계산:**
```
npmi = pmi / Math.log(cooccurrence)
```
정규화된 PMI(Normalized PMI)는 빈도 효과를 고려하여 단어 쌍 간 비교를 더 공정하게 만듭니다.

#### 6. 샘플 세션과 Theta 스냅샷

```
Session:
  mode: 'learning'
  itemsPracticed: 0
  stageTransitions: 0
  fluencyTaskCount: 0
  versatilityTaskCount: 0

ThetaSnapshot:
  thetaGlobal: 0
  theta[all components]: 0
  seGlobal: 1.0 (high uncertainty)
```

**왜 빈 세션을 생성하는가?**

이것은 사용자가 애플리케이션을 열었지만 아직 연습을 시작하지 않은 상태를 나타냅니다. theta 스냅샷은 세션 시작 시 능력 추정치를 캡처합니다:
- **seGlobal = 1.0**: 1.0의 표준 오차는 사용자의 실제 능력에 대한 높은 불확실성을 나타냄
- **theta = 0**: 모집단 평균에 중심을 둔 사전 추정치

사용자가 질문에 답할수록 IRT는 theta 추정치를 업데이트하고 표준 오차를 줄입니다.

---

### 미시적 규모: 직접적 관계 (Microscale: Direct Relationships)

#### 의존성 (이 스크립트가 필요로 하는 것)

- **`@prisma/client`**: 데이터베이스 작업을 위해 생성된 Prisma 클라이언트
- **데이터베이스 스키마** (`prisma/schema.prisma`): 테이블과 관계 정의
- **환경 변수** (`DATABASE_URL`): SQLite 데이터베이스 파일 경로 지정

#### 이 스크립트가 시드하는 파일

| 모델 | 개수 | 목적 |
|-------|-------|---------|
| User | 1 | CELBAN을 준비하는 브라질 간호사 |
| GoalSpec | 1 | 4개월 기한의 CELBAN 자격증 |
| LanguageObject | 20 | IRT 매개변수가 있는 의료 어휘 |
| MasteryState | 20 | 각 단어에 대한 초기 숙달 추적 |
| Collocation | 9 | PMI 가중치가 적용된 단어 쌍 |
| Session | 1 | 빈 학습 세션 |
| ThetaSnapshot | 1 | 초기 능력 추정치 |

#### 데이터 흐름

```
스크립트 실행
        |
        v
Prisma 클라이언트가 SQLite에 연결
        |
        v
'upsert'로 사용자 생성 (멱등성)
        |
        v
사용자에 연결된 목표 생성
        |
        v
목표에 연결된 20개 LanguageObject 생성
        |
        |---> objectMap이 id 매핑 추적
        |
        v
LanguageObject에 연결된 20개 MasteryState 생성
        |
        v
objectMap 조회를 사용하여 9개 Collocation 생성
        |
        v
사용자와 목표에 연결된 세션 생성
        |
        v
세션에 연결된 ThetaSnapshot 생성
        |
        v
요약 로깅, Prisma 연결 해제
```

---

### 거시적 규모: 시스템 통합 (Macroscale: System Integration)

#### 아키텍처 역할

시드 스크립트는 LOGOS의 **개발 인프라 레이어**에 위치합니다:

```
┌─────────────────────────────────────────────────────┐
│ Layer 1: Renderer (React UI)                        │
├─────────────────────────────────────────────────────┤
│ Layer 2: Main Process (Electron IPC, Services)      │
├─────────────────────────────────────────────────────┤
│ Layer 3: Data Access (Prisma, Repositories)         │
├─────────────────────────────────────────────────────┤
│ Layer 4: Database (SQLite)                          │
├─────────────────────────────────────────────────────┤
│ Development Infrastructure ← [SEED SCRIPT HERE]    │
│ (Migrations, Seeds, Build Tools)                    │
└─────────────────────────────────────────────────────┘
```

런타임 애플리케이션의 일부는 아니지만, 시드 스크립트는 개발을 가능하게 하는 **필수 인프라**입니다.

#### 큰 그림의 영향

**시드 스크립트 없이:**
- 개발자가 UI를 통해 수동으로 테스트 데이터를 생성해야 함 (느리고 오류 발생 가능)
- 통합 테스트에 테스트할 기준 데이터가 없음
- 데모 환경이 비어 있는 상태로 시작하여 모든 프레젠테이션에 설정 필요
- 현실적인 데이터 분포 없이 알고리즘 디버깅이 어려움

**시드 스크립트 사용 시:**
- 하나의 명령으로 완전하고 현실적인 데이터셋 생성
- 모든 팀원이 동일한 테스트 데이터로 작업 (재현 가능)
- 특정 난이도 분포에 대해 알고리즘 테스트 가능
- PMI 계산에 처리할 실제 연어 데이터 존재

#### 시드된 데이터가 시스템을 어떻게 테스트하는가

| 시스템 구성요소 | 시드 데이터가 테스트하는 방법 |
|------------------|----------------------|
| **IRT 엔진** | 난이도 범위 -0.8 ~ +1.2의 어휘가 전체 척도 테스트 |
| **FSRS 스케줄러** | 새 카드가 초기 스케줄링 로직 테스트 |
| **PMI 분석기** | PMI 2.1-4.2의 연어가 추천 시스템 테스트 |
| **단계 시스템** | 단계 0 항목이 승급 기준 테스트 |
| **목표 진행** | 0% 완료가 진행률 계산 테스트 |
| **세션 분석** | 빈 세션이 엣지 케이스 처리 테스트 |

#### 중요 경로 분석

**중요도 수준**: 개발에 중요 (런타임에는 중요하지 않음)

- **시드 실패 시**: 개발 환경에 테스트 데이터 없음; 수동 설정 필요
- **시드가 잘못된 데이터 생성 시**: 알고리즘이 올바르게 작동할 때 고장난 것처럼 보일 수 있음
- **시드가 스키마와 동기화되지 않은 경우**: 스크립트 충돌, 온보딩 차단

**복구 전략**: 스크립트는 `upsert` 작업을 사용하여 **멱등성(idempotent)** 을 가집니다 (여러 번 실행해도 안전). 시드를 두 번 실행해도 데이터가 중복되지 않습니다.

---

### 기술 개념 (평이한 설명)

#### Upsert 패턴

**기술적**: 레코드가 존재하지 않으면 삽입하고, 존재하면 아무것도 하지 않거나 업데이트하는 데이터베이스 작업. Prisma의 `upsert`는 `where`(찾기 기준), `create`(찾지 못한 경우), `update`(찾은 경우) 절을 받습니다.

**평이한 설명**: 호텔 체크인과 같습니다. 새 손님이면 예약을 만듭니다. 이미 있으면 그냥 조회합니다. 같은 숙박에 실수로 두 개의 방을 받는 일은 없습니다.

**사용 이유**: 시드 스크립트를 중복 레코드 생성 없이 여러 번 실행할 수 있습니다. 첫 번째 실행은 데이터를 생성하고, 이후 실행은 아무 작업도 하지 않습니다.

#### PMI (Pointwise Mutual Information, 점별 상호정보량)

**기술적**: 두 사건이 독립적인 경우보다 얼마나 더 많이(또는 적게) 동시에 발생하는지를 정량화하는 정보 이론의 측정값. 공식: `PMI(x,y) = log(P(x,y) / (P(x) * P(y)))`

**평이한 설명**: "blood"와 "pressure"가 랜덤한 확률이 예측하는 것보다 훨씬 더 자주 함께 나타나면(각 단어가 개별적으로 얼마나 흔한지를 고려할 때) 높은 PMI를 가집니다. 두 학생이 수업에서 항상 함께 앉는 것을 알아채는 것과 같습니다 - 아마 우연이 아닐 것입니다.

**사용 이유**: 높은 PMI를 가진 연어(단어 쌍)는 함께 배우는 것이 중요합니다. "blood"를 아는 학습자는 의료 텍스트에서 "blood pressure"를 끊임없이 접하게 될 것이므로 "pressure" 학습을 우선시해야 합니다.

#### IRT 난이도 척도

**기술적**: 문항반응이론(Item Response Theory)에서 난이도(b 매개변수)는 일반적으로 -3에서 +3 범위의 로짓 척도로 측정되며 0을 중심으로 합니다(평균 난이도). 능력 theta = b인 학습자는 정답을 맞출 확률이 50%입니다.

**평이한 설명**: 스키 슬로프 등급과 같습니다. "0" 난이도 단어는 블루 스퀘어입니다 - 초보자에게는 도전적이고 전문가에게는 쉽습니다. "anaphylaxis"와 같은 "+1.2" 단어는 블랙 다이아몬드입니다 - 고급 학습자만 일관되게 처리할 수 있습니다.

**사용 이유**: 시드 데이터의 난이도 구배(-0.8 ~ +1.2)는 다양한 능력 수준의 학습자에게 적절하게 도전적인 항목을 선택하는 IRT 엔진의 능력을 테스트합니다.

#### Theta (능력 추정치)

**기술적**: 학습자의 기저 능숙도를 나타내는 IRT의 잠재 특성 매개변수. 각 응답 후 베이지안 추론을 사용하여 업데이트됩니다. 더 많은 응답이 관찰될수록 표준 오차(SE)가 감소합니다.

**평이한 설명**: 의료 영어에서의 "진정한 실력"입니다. 직접 관찰할 수는 없지만 어떤 질문에 올바르게 답하는지를 기반으로 추정합니다. 더 많은 질문에 답할수록 추정치에 대한 확신이 높아집니다.

**사용 이유**: SE = 1.0인 Theta = 0은 최대 불확실성을 나타냅니다 - 사용자가 그 반대를 증명하기 전까지 평균이라고 가정합니다. 이 사전 확률은 첫 번째 학습 세션 동안 빠르게 정제됩니다.

#### 멱등 연산 (Idempotent Operations)

**기술적**: 몇 번을 실행해도 같은 결과를 생성하는 연산. `f(f(x)) = f(x)`.

**평이한 설명**: 엘리베이터 버튼을 여러 번 누르는 것과 같습니다 - 여러 대의 엘리베이터를 호출하지 않고, 단지 올라가고 싶다는 것을 등록합니다. 시드 스크립트도 같은 방식으로 작동합니다: 5번 실행해도 1번 실행한 것과 같은 데이터를 생성합니다.

**사용 이유**: 스크립트를 다시 실행할 때 실수로 중복 사용자, 목표 또는 어휘 항목을 생성하는 "시드 오염"을 방지합니다. 정리 없이 디버깅 중 실행해도 안전합니다.

---

### 시드된 어휘 세트

참조용으로, 시드가 생성하는 20개 의료 용어입니다:

| 용어 | 난이도 | 빈도 | 정의 |
|------|------------|-----------|------------|
| administer | -0.5 | 0.89 | 환자에게 약물이나 치료를 제공하다 |
| assess | -0.3 | 0.91 | 환자의 상태를 평가하거나 판단하다 |
| contraindication | 0.8 | 0.67 | 치료를 권장하지 않는 조건 |
| bilateral | 0.3 | 0.58 | 신체 양쪽에 영향을 미치는 |
| catheterize | 0.6 | 0.42 | 카테터를 신체에 삽입하다 |
| auscultate | 0.9 | 0.35 | 청진기로 체내 소리를 듣다 |
| prognosis | 0.2 | 0.71 | 질병이나 상태의 예상 경과 |
| symptom | -0.7 | 0.94 | 상태의 신체적 또는 정신적 징후 |
| diagnosis | -0.4 | 0.92 | 증상으로부터 질병을 식별하는 것 |
| prescription | -0.2 | 0.88 | 약물에 대한 서면 처방 |
| triage | 0.5 | 0.65 | 치료의 긴급성에 따라 환자 분류 |
| vital signs | -0.6 | 0.93 | 맥박, 체온 같은 기본 신체 측정값 |
| edema | 0.4 | 0.54 | 체액 축적으로 인한 부종 |
| hemorrhage | 0.7 | 0.48 | 심한 출혈 |
| anaphylaxis | 1.2 | 0.31 | 심각한 알레르기 반응 |
| intubate | 0.8 | 0.38 | 기도에 튜브를 삽입하다 |
| monitor | -0.8 | 0.95 | 환자 상태를 관찰하고 추적하다 |
| discharge | -0.1 | 0.82 | 환자를 치료에서 퇴원시키다 |
| chronic | 0.1 | 0.79 | 장기간 지속되거나 재발하는 상태 |
| acute | 0.0 | 0.81 | 갑작스럽고 심한 상태 |

---

### 변경 이력

#### 2026-01-04 - 문서 생성
- **변경 내용**: Prisma 시드 스크립트에 대한 초기 내러티브 문서
- **이유**: 데이터 시딩 전략을 설명하는 섀도우 문서 수립
- **영향**: 미래 개발자가 테스트 데이터의 목적과 구조를 이해

---

*이 문서는 `prisma/seed.ts`를 반영합니다*

---

## 2. Vitest 설정 (Vitest Configuration)

> **최종 업데이트**: 2026-01-04
> **코드 위치**: `vitest.config.ts`
> **상태**: 활성

---

### 컨텍스트 및 목적 (Context & Purpose)

이 설정 파일은 Vitest(테스팅 프레임워크)가 LOGOS 애플리케이션 전반에 걸쳐 자동화된 테스트를 실행하는 방법을 정의합니다. 이것은 핵심 알고리즘과 비즈니스 로직이 올바르게 작동하는지 검증하는 신뢰할 수 있고, 빠르고, 일관된 테스트 실행에 대한 중요한 필요성을 해결합니다.

**비즈니스 요구사항**: LOGOS는 수학적으로 정확한 결과를 생성해야 하는 정교한 적응형 학습 알고리즘(IRT, FSRS, PMI)을 사용합니다. 자동화된 테스트 없이는 어떤 코드 변경이든 학습 알고리즘을 조용히 망가뜨릴 수 있으며, 이는 잘못된 난이도 평가나 스케줄링으로 이어져 전체 사용자 학습 경험을 저하시킬 수 있습니다.

**사용 시점**:
- 개발자가 `npm test` 또는 `npm run test:coverage`를 실행할 때마다
- CI(지속적 통합) 파이프라인 중
- 개발자가 자신의 변경 사항이 기존 기능을 망가뜨리지 않았는지 확인하고 싶을 때

---

### 미시적 규모: 직접적 관계 (Microscale: Direct Relationships)

#### 의존성 (이것이 필요로 하는 것)
- `vitest/config`: defineConfig() - Vitest에 대한 타입 안전 설정 구조 제공
- `path` (Node.js 내장): path.resolve() - 모듈 별칭을 위한 절대 경로 구성

#### 종속자 (이것을 필요로 하는 것)
- `package.json`: `test`와 `test:coverage` 스크립트가 이 설정을 읽는 Vitest를 호출
- `src/**/*.{test,spec}.{ts,tsx}`의 모든 테스트 파일: `include` 패턴을 기반으로 발견되고 실행됨
- 현재 발견된 테스트 파일:
  - `src/core/__tests__/irt.test.ts` - 문항반응이론(Item Response Theory) 알고리즘 테스트
  - `src/core/__tests__/fsrs.test.ts` - 자유 간격 반복 스케줄러(Free Spaced Repetition Scheduler) 테스트
  - `src/core/__tests__/pmi.test.ts` - 점별 상호정보량(Pointwise Mutual Information) 테스트
  - `src/core/__tests__/priority.test.ts` - 우선순위 계산 테스트
  - `src/core/__tests__/bottleneck.test.ts` - 병목 감지 테스트
  - `src/core/__tests__/g2p.test.ts` - 자소-음소 변환(Grapheme-to-phoneme) 테스트
  - `src/core/__tests__/morphology.test.ts` - 형태소 분석 테스트

#### 설정 관계
- `tsconfig.json`: 여기에 정의된 경로 별칭(`@`, `@core`, `@main`, `@renderer`, `@shared`)은 TypeScript 설정의 것과 동일하여 테스트에서 프로덕션 코드와 같은 방식으로 모듈을 임포트할 수 있음

#### 데이터 흐름
```
개발자가 `npm test` 실행
    --> Vitest가 이 설정 파일 로드
    --> include 패턴과 일치하는 테스트 파일 발견
    --> node_modules, dist, .git 제외
    --> Node.js 환경 설정
    --> 테스트 실행 중 임포트 별칭 해석
    --> 10초 타임아웃으로 테스트 실행
    --> 결과 보고 (요청 시 커버리지도)
```

---

### 거시적 규모: 시스템 통합 (Macroscale: System Integration)

#### 아키텍처 레이어

이 설정은 LOGOS 아키텍처의 **개발 인프라 레이어**에 위치합니다:

```
사용자 대면 레이어:
  - Layer 1: Renderer (React UI)
  - Layer 2: Main Process (Electron IPC, Services)
  - Layer 3: Core Algorithms (IRT, FSRS, PMI)
  - Layer 4: Database (Prisma + SQLite)

개발 인프라:
  - **Vitest Config** (현재 위치) - 테스트 실행
  - TypeScript Config - 타입 검사
  - ESLint Config - 코드 품질
  - Electron-Vite Config - 빌드 도구
```

#### 큰 그림의 영향

이 설정은 전체 코드베이스의 **품질 게이트**입니다. 다음을 보장합니다:

1. **알고리즘 정확성**: 핵심 학습 알고리즘(능력 추정을 위한 IRT, 스케줄링을 위한 FSRS, 연어 감지를 위한 PMI)이 수학적으로 검증됨
2. **회귀 방지**: 시스템의 어떤 부분에 대한 변경도 기존 동작에 대해 검증됨
3. **개발자 신뢰**: 엔지니어가 테스트가 주요 변경 사항을 포착할 것임을 알고 코드를 리팩토링할 수 있음

#### 중요 경로 분석

**중요도 수준**: 높음 (개발 인프라)

- **이것이 실패하면**: 테스트를 실행할 수 없어 개발자가 의존하는 피드백 루프가 끊어짐
- **잘못 설정되면**: 테스트가 잘못 통과하거나(거짓 양성) 버그를 찾지 못할 수 있음(거짓 음성)
- **커버리지 범위**: 특히 `src/core/**/*.ts` - 알고리즘 레이어 - 를 대상으로 함. 그곳의 오류가 사용자 영향이 가장 크기 때문

**왜 Core만 커버리지?**
커버리지 설정이 의도적으로 `src/core/**/*.ts`에 집중하는 이유:
- 핵심 알고리즘은 결정적 출력을 가진 순수 함수 - 단위 테스트에 이상적
- UI 컴포넌트(renderer)는 통합/E2E 테스트로 더 잘 테스트됨
- 서비스 레이어(main)는 모킹이 필요한 부작용을 포함

---

### 기술 개념 (평이한 설명)

#### globals: true

**기술적**: Vitest의 테스트 함수(`describe`, `it`, `expect`)를 명시적 임포트 없이 전역 범위에 주입합니다.

**평이한 설명**: 모든 테스트 파일 상단에 `import { describe, it, expect } from 'vitest'`를 작성하는 대신, 이 함수들이 어디서나 자동으로 사용 가능합니다 - `console.log`가 임포트 없이 항상 사용 가능한 것처럼.

**사용 이유**: 테스트 파일의 보일러플레이트를 줄여 더 깔끔하고 빠르게 작성할 수 있게 합니다.

#### environment: 'node'

**기술적**: 테스트 런타임을 브라우저 유사 환경(jsdom)이 아닌 Node.js 환경을 사용하도록 설정합니다.

**평이한 설명**: 테스트가 웹 브라우저가 아닌 서버(Node.js)에서 실행되는 것처럼 실행됩니다. 핵심 알고리즘이 `window`나 `document` 같은 브라우저 기능을 필요로 하지 않기 때문에 적절합니다.

**사용 이유**: 핵심 알고리즘은 순수 TypeScript/JavaScript 로직입니다 - 숫자를 계산하고 데이터를 변환합니다. DOM이나 브라우저 API를 건드리지 않습니다.

#### coverage.provider: 'v8'

**기술적**: V8 JavaScript 엔진의 내장 코드 커버리지 기능을 사용하여 테스트 중 실행되는 코드 라인을 추적합니다.

**평이한 설명**: 테스트가 실제로 실행하는 모든 코드 라인에 표시하는 형광펜과 같습니다. V8은 Node.js와 Chrome을 구동하는 엔진이므로 추가 도구 없이 네이티브하게 커버리지를 추적할 수 있습니다.

**사용 이유**: V8 커버리지는 JavaScript 엔진 자체에 내장되어 있기 때문에 위에 덧붙이는 것보다 빠르고 정확합니다.

#### coverage.reporter: ['text', 'json', 'html']

**기술적**: 세 가지 형식으로 커버리지 보고서를 생성합니다: 터미널 출력, 기계 판독 가능한 JSON, 탐색 가능한 HTML.

**평이한 설명**:
- `text`: 테스트가 끝나면 터미널에 바로 커버리지 요약을 표시
- `json`: CI 시스템이 시간에 따른 커버리지를 추적하기 위해 파싱할 수 있는 데이터 생성
- `html`: 어떤 라인이 커버되었는지(녹색) 또는 누락되었는지(빨강) 정확히 볼 수 있는 미니 웹사이트 생성

**사용 이유**: 다른 대상이 다른 형식을 필요로 합니다 - 개발자는 터미널 출력, CI는 JSON, 코드 리뷰어는 HTML 시각화를 원합니다.

#### 경로 별칭 (@, @core, @main, @renderer, @shared)

**기술적**: 단축 경로를 절대 디렉토리 위치에 매핑하도록 모듈 해석을 설정합니다.

**평이한 설명**: `../../../core/fsrs` 같은 지저분한 상대 임포트를 작성하는 대신 `@core/fsrs` 같은 깔끔한 임포트를 작성할 수 있습니다. 전화의 단축 다이얼을 설정하는 것과 같습니다 - `@core`는 항상 "src/core 폴더로 가라"를 의미합니다.

**사용 이유**:
1. 임포트를 읽기 쉽고 일관되게 만듦
2. 파일이 깊이 중첩되어 있을 때 "임포트 지옥"을 방지
3. TypeScript 설정과 동일하여 테스트와 프로덕션에서 임포트가 같은 방식으로 작동

#### testTimeout / hookTimeout: 10000

**기술적**: 개별 테스트와 설정/해체 훅에 대한 최대 실행 시간(밀리초)을 설정합니다.

**평이한 설명**: 단일 테스트가 10초 이상 걸리면 Vitest는 "멈춤"으로 간주하고 실패시킵니다. 이것은 무언가 잘못되었을 때 테스트가 영원히 멈추는 것을 방지합니다.

**사용 이유**: 핵심 알고리즘은 밀리초 내에 결과를 계산해야 합니다. 10초 타임아웃은 넉넉하지만 무한 루프나 해결되지 않은 프로미스를 잡아냅니다.

---

### 설정 결정 및 근거 (Configuration Decisions & Rationale)

#### 왜 테스트 파일에 대한 커버리지를 제외하는가?
```typescript
exclude: [
  'src/core/**/*.test.ts',
  'src/core/**/*.spec.ts',
  'src/core/types.ts',
]
```
- **테스트 파일**: 테스트 코드 자체의 커버리지를 측정하는 것은 의미 없음 - 테스트는 측정 도구이지 측정 대상이 아님
- **types.ts**: 타입 정의 파일에는 커버할 런타임 코드가 없음 - 컴파일 타임 전용

#### 왜 Include 패턴이 .test와 .spec 둘 다 사용하는가?
```typescript
include: ['src/**/*.{test,spec}.{ts,tsx}']
```
개발자마다 선호하는 명명 규칙이 다릅니다. 두 규칙을 모두 지원:
- `.test.ts` - Jest/Vitest 생태계에서 일반적
- `.spec.ts` - Jasmine/Angular 생태계에서 일반적

이 유연성은 명명 규칙 논쟁을 방지하고 다양한 배경의 기여자를 환영합니다.

---

### 변경 이력

#### 2026-01-04 - 초기 문서화
- **변경 내용**: vitest.config.ts에 대한 내러티브 문서 생성
- **이유**: 테스팅 인프라를 설명하는 섀도우 문서 수립
- **영향**: 미래 개발자가 설정을 역공학하지 않고도 테스팅 설정을 이해할 수 있음

---

*이 문서는 `vitest.config.ts`를 반영합니다*

---

## 3. 아이콘 생성기 스크립트 (Icon Generator Script)

> **최종 업데이트**: 2026-01-04
> **코드 위치**: `scripts/generate-icons.js`
> **상태**: 활성

---

### 컨텍스트 및 목적 (Context & Purpose)

이 스크립트는 일반적인 개발 마찰점을 해결하기 위해 존재합니다: Electron 애플리케이션은 각 운영 체제(Windows, macOS, Linux)에 대해 특정 형식과 크기의 아이콘 파일을 필요로 하지만, 개발자들은 종종 초기 개발 단계에서 이러한 자산을 준비하지 않습니다. 빌드 프로세스를 차단하거나 수동 플레이스홀더 생성을 요구하는 대신, 이 스크립트는 프로그래밍 방식으로 유효한 PNG 아이콘 파일을 생성합니다.

**비즈니스/사용자 요구사항**: LOGOS 데스크톱 애플리케이션은 Windows, macOS, Linux 전반에 배포를 위해 패키징되어야 합니다. electron-builder 도구는 패키징이 성공하기 전에 유효한 아이콘 자산이 존재해야 합니다. 이 스크립트는 개발자가 디자인 팀의 최종 브랜딩 자산을 기다리지 않고 전체 빌드 파이프라인을 테스트할 수 있게 합니다.

**사용 시점**:
- 디자인 자산이 사용 가능하기 전 초기 프로젝트 설정 중
- 빌드 설정을 테스트할 때 CI/CD 파이프라인에서
- 패키징이 자신의 머신에서 작동하는지 확인해야 하는 개발자
- PNG 파일 형식 요구사항을 이해하기 위한 템플릿/참조로

---

### 미시적 규모: 직접적 관계 (Microscale: Direct Relationships)

#### 의존성 (이것이 필요로 하는 것)
- `fs` (Node.js 내장): 디렉토리 생성 및 아이콘 파일 작성을 위한 파일 시스템 작업
- `path` (Node.js 내장): 올바른 파일 경로를 구성하기 위한 크로스 플랫폼 경로 조작
- `zlib` (Node.js 내장): DEFLATE 알고리즘을 사용한 데이터 압축 (PNG 사양에 필요)

#### 종속자 (이것을 필요로 하는 것)
- `electron-builder.yml`: 이 스크립트가 채우는 아이콘 경로를 참조:
  - `resources/icon.ico` (Windows) - 이 스크립트로 생성되지 않음, 수동 생성 필요
  - `resources/icon.icns` (macOS) - 이 스크립트로 생성되지 않음, 수동 생성 필요
  - `resources/icons/*.png` (Linux) - **이 스크립트로 생성됨**
  - `resources/icon.png` (폴백) - **이 스크립트로 생성됨**
- `package.json` 스크립트: `pack`과 `dist` 명령이 아이콘 존재에 의존

#### 데이터 흐름
```
스크립트 실행
    |
    v
resources/icons/ 디렉토리 생성 (없는 경우)
    |
    v
각 크기 [16, 32, 48, 64, 128, 256, 512]에 대해:
    |
    +---> PNG 바이너리 데이터 생성 (보라색 사각형)
    |         |
    |         +---> PNG 시그니처 (8바이트 매직 넘버)
    |         +---> IHDR 청크 (크기가 포함된 이미지 헤더)
    |         +---> IDAT 청크 (압축된 픽셀 데이터)
    |         +---> IEND 청크 (종료 마커)
    |
    +---> resources/icons/{size}x{size}.png에 작성
    |
    v
256x256 메인 아이콘 생성
    |
    v
resources/icon.png에 작성
    |
    v
프로덕션 교체 지침과 함께 완료 메시지 출력
```

---

### 거시적 규모: 시스템 통합 (Macroscale: System Integration)

#### 아키텍처 레이어

이 스크립트는 LOGOS 애플리케이션의 **빌드 인프라 레이어**에서 작동합니다:

```
애플리케이션 레이어:
+--------------------------------+
| Layer 5: Distribution          | <-- 패키징된 인스톨러 (.exe, .dmg, .deb)
+--------------------------------+
| Layer 4: Packaging             | <-- electron-builder가 여기서 아이콘 소비
+--------------------------------+
| Layer 3: Build Output          | <-- dist/의 컴파일된 JavaScript
+--------------------------------+
| Layer 2: Source Code           | <-- TypeScript/React 소스 파일
+--------------------------------+
| Layer 1: Build Scripts         | <-- 이 스크립트가 여기 위치
+--------------------------------+
```

#### 큰 그림의 영향

이 유틸리티 스크립트는 LOGOS의 완전한 개발자 경험을 가능하게 합니다:

1. **CI/CD 파이프라인 활성화**: 자동화된 빌드가 수동 자산 준비 없이 완료될 수 있음
2. **온보딩 마찰 감소**: 새 개발자가 저장소를 클론하고 즉시 `npm run dist`를 실행하여 패키징을 테스트할 수 있음
3. **PNG 형식 문서화**: 구현이 PNG 파일 사양을 이해하기 위한 교육적 참조 역할 (아이콘 관련 패키징 문제 디버깅에 유용)
4. **브랜드 색상 확립**: 보라색(`#6B46C1`)을 플레이스홀더로 사용하여 개발 빌드에서도 LOGOS 브랜드 색상 확립

**시스템 의존성**:
이것은 낮은 중요도를 가진 **유틸리티** 컴포넌트입니다 - 실패하거나 제거되면:
- 개발 빌드는 여전히 작동 (`npm run dev`에는 아이콘 불필요)
- 프로덕션 빌드는 아이콘 파일이 없는 경우에만 실패
- PNG 파일을 생성하는 모든 도구(ImageMagick, GIMP 등)로 대체 가능

#### 중요 경로 분석

**중요도 수준**: 낮음-중간

- **이것이 실패하면**: 개발자가 수동으로 플레이스홀더 아이콘을 만들거나 외부 도구 사용해야 함
- **실패 모드**: "아이콘을 찾을 수 없음" 오류로 빌드 패키징 실패
- **백업 대안**:
  - `electron-icon-maker` npm 패키지
  - 온라인 아이콘 생성기
  - 이미지 편집 소프트웨어로 수동 생성
  - `ImageMagick convert` 명령줄 도구

---

### 기술 개념 (평이한 설명)

#### PNG 파일 형식

**기술적**: PNG(Portable Network Graphics, 이동식 네트워크 그래픽)는 DEFLATE 압축을 사용하고 투명도를 지원하는 무손실 압축 래스터 이미지 형식입니다. 8바이트 시그니처 다음에 일련의 타입화된 청크(IHDR, IDAT, IEND)로 구성됩니다.

**평이한 설명**: PNG 파일은 이미지를 위한 신중하게 포장된 배송 컨테이너와 같습니다. 컨테이너는 컴퓨터에게 "이것은 확실히 PNG 파일입니다"라고 알려주는 특별한 라벨(시그니처)로 시작합니다. 내부에는 라벨이 붙은 구획(청크)이 있습니다: 하나는 이미지 크기와 색상 유형을 설명하고(IHDR), 하나는 실제 압축된 그림 데이터를 포함하며(IDAT), 하나는 끝을 표시합니다(IEND). 각 구획에는 손상된 것이 없는지 확인하는 체크섬 숫자가 포함됩니다.

**사용 이유**: PNG는 투명도를 지원하고(비직사각형 아이콘에 중요) JPEG처럼 품질을 잃지 않기 때문에 Linux에서 애플리케이션 아이콘의 표준 형식입니다. Electron-builder는 특히 Linux 패키징을 위해 PNG 파일을 요구합니다.

#### CRC32 체크섬

**기술적**: CRC32(순환 중복 검사, 32비트)는 다항식 나눗셈을 사용하여 임의의 데이터에서 고정 크기 체크섬을 생성하는 오류 감지 코드입니다. PNG는 데이터 무결성을 확인하기 위해 각 청크 끝에 CRC32를 요구합니다.

**평이한 설명**: 모든 항목이 올바르게 스캔되었음을 증명하는 영수증 합계와 같습니다. CRC32는 모든 데이터를 고유한 32비트 "지문"으로 바꾸는 수학 공식입니다. 단 하나의 바이트라도 변경되면 지문이 완전히 바뀝니다. PNG 리더는 이것을 사용하여 손상된 파일을 감지합니다 - 지문이 일치하지 않으면 다운로드나 저장 중에 무언가 잘못된 것입니다.

**사용 이유**: PNG 사양은 CRC32 체크섬을 의무화합니다. 유효한 체크섬 없이는 이미지 뷰어와 electron-builder가 생성된 아이콘을 손상된 것으로 거부합니다.

#### DEFLATE 압축

**기술적**: DEFLATE는 LZ77 사전 인코딩과 허프만 코딩을 결합한 무손실 데이터 압축 알고리즘입니다. zlib 래퍼를 통해 PNG의 IDAT 청크에서 사용됩니다.

**평이한 설명**: DEFLATE는 반복 패턴을 찾아 데이터를 반복하는 대신 단축키를 저장하는 스마트 포장 방법과 같습니다. 보라색 픽셀이 256번 연속으로 나타나면 "보라색, 보라색, 보라색..."을 256번 쓰는 대신 "보라색 x 256"이라고 합니다. Node.js zlib 모듈이 이 압축을 자동으로 수행합니다.

**사용 이유**: PNG는 DEFLATE 압축을 요구합니다 - 선택 사항이 아닙니다. Node의 내장 zlib 모듈을 사용하면 유효한 PNG 파일을 만들기 위해 외부 의존성이 필요하지 않습니다.

#### 플레이스홀더 아이콘

**기술적**: 최종 브랜딩을 나타내지 않으면서 도구 요구사항을 충족하는 개발 중 사용되는 임시 자산.

**평이한 설명**: 디자이너가 목업에서 사용하는 "lorem ipsum" 더미 텍스트와 같습니다. 이 보라색 사각형들은 electron-builder에게 "예, 여기에 아이콘이 있습니다"라고 말해서 빌드가 완료될 수 있지만, 분명히 최종 제품이 아닙니다. 스크립트는 개발자에게 프로덕션 릴리스 전에 이것들을 실제 브랜딩으로 교체하라고 명시적으로 경고합니다.

**사용 이유**: 병렬 작업 스트림을 허용합니다 - 개발자는 패키징과 배포 작업을, 디자이너는 브랜딩 자산 작업을 할 수 있습니다. 어느 팀도 다른 팀을 차단하지 않습니다.

---

### 구현 노트

#### 색상 선택
스크립트는 보라색 사각형(`RGB: 107, 70, 193` / `#6B46C1`)을 생성하는데, 이는 LOGOS 브랜드 색상으로 보입니다. 이것은 플레이스홀더 아이콘도 애플리케이션의 아이덴티티와 시각적 일관성을 유지하도록 보장합니다.

#### 크기 매트릭스
스크립트는 다양한 DPI 설정과 컨텍스트(시스템 트레이, 독, 파일 관리자 등)에서 애플리케이션 아이콘에 대해 Linux 데스크톱 환경이 기대하는 표준 크기와 일치하는 `[16, 32, 48, 64, 128, 256, 512]` 픽셀 크기의 아이콘을 생성합니다.

#### 플랫폼 커버리지
- **Linux**: `resources/icons/`의 PNG 파일로 완전히 커버
- **Windows**: 수동 `.ico` 파일 생성 필요 (ICO 형식 생성되지 않음)
- **macOS**: 수동 `.icns` 파일 생성 필요 (ICNS 형식 생성되지 않음)

스크립트 출력은 어떤 형식이 수동 교체가 필요한지 명시적으로 나열합니다.

---

### 변경 이력

#### 2026-01-04 - 문서 생성
- **변경 내용**: 이 빌드 유틸리티 스크립트에 대한 내러티브 문서 생성
- **이유**: 모든 코드 파일에 대한 Shadow Map 문서화 요구사항
- **영향**: 개발자가 이제 이 스크립트가 왜 존재하고 빌드 시스템에 어떻게 맞는지에 대한 컨텍스트를 가짐

---

*이 문서는 `scripts/generate-icons.js`를 반영합니다*

---

## 4. Electron-Vite 빌드 설정 (Electron-Vite Build Configuration)

> **최종 업데이트**: 2026-01-05
> **코드 위치**: `electron.vite.config.ts`
> **상태**: 활성

---

### 컨텍스트 및 목적 (Context & Purpose)

이 설정 파일은 전체 LOGOS 데스크톱 애플리케이션의 **빌드 오케스트레이터(build orchestrator)** 입니다. 이것은 electron-vite에게 함께 작동해야 하는 근본적으로 다른 세 가지 유형의 코드를 어떻게 컴파일하고 번들링할지 알려줍니다: 메인 프로세스(백엔드), 프리로드 스크립트(보안 브릿지), 그리고 렌더러(프론트엔드 UI).

**비즈니스 요구사항**: LOGOS는 Electron으로 구축된 언어 학습 데스크톱 애플리케이션입니다. Electron을 사용하는 데스크톱 앱은 고유한 도전에 직면합니다 - Node.js 백엔드 코드와 브라우저 기반 React UI를 동시에 실행해야 하며, 이들 사이에 보안 브릿지가 필요합니다. 이 설정은 세 조각 모두 올바르게 컴파일되고 런타임에 서로를 찾을 수 있도록 보장합니다.

**사용 시점**: 개발자가 `npm run dev`(개발 모드), `npm run build`(프로덕션 빌드), 또는 `npm run preview`(프로덕션 빌드 미리보기)를 실행할 때마다, 이 설정 파일은 electron-vite에 의해 읽히고 실행되어 전체 빌드 프로세스를 조정합니다.

---

### 미시적 규모: 직접적 관계 (Microscale: Direct Relationships)

#### 의존성 (이것이 필요로 하는 것)

- `electron-vite`: 이 설정을 읽고 실행하는 빌드 도구 - `defineConfig` 함수와 `externalizeDepsPlugin` 제공
- `@vitejs/plugin-react`: 렌더러 프로세스를 위한 React JSX 컴파일과 Fast Refresh를 활성화하는 Vite 플러그인
- `path` (Node.js): 진입점과 별칭을 위한 절대 경로를 생성하는 `resolve()` 사용

#### 진입점 (이것이 설정하는 것)

- **메인 프로세스 진입점**: `src/main/index.ts` - 윈도우 생성, IPC 처리, 앱 수명주기 관리를 담당하는 Electron 메인 프로세스
- **프리로드 스크립트 진입점**: `src/main/preload.ts` - contextBridge를 통해 메인에서 렌더러로 안전한 API를 노출하는 보안 브릿지
- **렌더러 진입점**: `src/renderer/index.html` - React 애플리케이션을 부트스트랩하는 HTML 파일

#### 정의된 경로 별칭

| 별칭 | 대상 디렉토리 | 사용처 |
|-------|------------------|---------|
| `@core` | `src/core` | 메인 프로세스, 렌더러 |
| `@main` | `src/main` | 메인 프로세스만 |
| `@shared` | `src/shared` | 메인 프로세스, 렌더러 |
| `@renderer` | `src/renderer` | 렌더러만 |

#### 이것에 의존하는 파일

- `package.json`: `dev`, `build`, `preview` 같은 스크립트가 이 설정을 읽는 electron-vite를 호출
- 경로 별칭(`@core`, `@main`, `@shared`, `@renderer`)을 사용하는 모든 TypeScript 파일이 여기의 별칭 정의에 의존
- 전체 빌드 파이프라인 - 이 설정 없이는 아무것도 컴파일되지 않음

---

### 거시적 규모: 시스템 통합 (Macroscale: System Integration)

#### 아키텍처 역할

이 설정은 **빌드 인프라 레이어**에 위치합니다 - 애플리케이션 자체의 일부가 아니라 애플리케이션을 가능하게 하는 기반입니다.

```
애플리케이션 아키텍처:
==========================
[Build Layer]     <-- electron.vite.config.ts (현재 위치)
      |
      v
[Main Process]    <-- src/main/index.ts (Node.js/Electron)
      |
      v (IPC Bridge)
[Preload Script]  <-- src/main/preload.ts (보안 샌드박스)
      |
      v (contextBridge)
[Renderer]        <-- src/renderer/ (React/Browser)
```

#### 큰 그림의 영향

**이 설정 없이 LOGOS 애플리케이션은 다음을 할 수 없습니다:**
- TypeScript를 JavaScript로 컴파일
- 배포를 위한 의존성 번들링
- 핫 리로드가 있는 개발 모드 실행
- 배포를 위한 프로덕션 빌드 생성

이것은 **기반 수준** 설정입니다. 빌드 시스템이 소스 코드에서 전체 애플리케이션을 구성하는 방법을 알려주는 청사진입니다.

#### 3-프로세스 아키텍처

LOGOS는 모든 Electron 앱처럼 이 설정이 오케스트레이션하는 세 개의 별개 JavaScript 컨텍스트를 실행합니다:

1. **메인 프로세스** (Node.js 환경)
   - Node.js API, 파일 시스템, 네이티브 모듈에 대한 전체 액세스
   - 윈도우, 메뉴, 시스템 트레이, 앱 수명주기 관리
   - Prisma/better-sqlite3를 통한 데이터베이스 작업 처리
   - `main:` 섹션에서 설정

2. **프리로드 스크립트** (샌드박스화된 브릿지)
   - 렌더러 로드 전에 격리된 컨텍스트에서 실행
   - 메인 프로세스 기능을 렌더러에 안전하게 노출하는 유일한 방법
   - `contextBridge.exposeInMainWorld()`를 사용하여 `window.logos` API 생성
   - `preload:` 섹션에서 설정

3. **렌더러 프로세스** (브라우저 환경)
   - 표준 웹 환경 - Node.js 액세스 없음 (보안을 위해)
   - UI를 위한 React 애플리케이션 실행
   - 프리로드 API를 통해서만 메인 프로세스와 통신
   - `renderer:` 섹션에서 설정

#### 중요한 설정 결정

**메인과 프리로드를 위한 externalizeDepsPlugin()**:
이 플러그인은 Vite에게 "node_modules를 번들링하지 말고 외부에 두라"고 지시합니다. 이것이 필수적인 이유:
- `better-sqlite3` 같은 네이티브 모듈은 번들링할 수 없음
- Electron 자체는 앱에 번들링되어서는 안 됨
- 메인 프로세스 빌드를 빠르고 Node.js와 호환되게 유지

**렌더러 전용 React 플러그인**:
렌더러만 React 컴파일이 필요합니다 - 메인 프로세스와 프리로드는 순수 Node.js/Electron 코드입니다.

**별도의 resolve.alias 설정**:
메인 프로세스는 `@renderer` 경로를 사용할 수 없고, 렌더러는 `@main` 경로를 사용할 수 없습니다. 이것은 빌드 수준에서 아키텍처 경계를 강제합니다.

---

### 기술 개념 (평이한 설명)

#### defineConfig()

**기술적**: 설정 객체에 대한 TypeScript 타입 검사와 자동완성을 제공하는 electron-vite의 헬퍼 함수.

**평이한 설명**: 미리 정의된 필드가 있는 양식과 같습니다 - 어떤 옵션이 유효한지 알고 올바르게 채울 수 있도록 도와줍니다. 오타를 내면 TypeScript가 경고합니다.

**사용 이유**: 설정 오류를 방지하고 타입을 통해 설정을 자기 문서화하게 만듭니다.

#### externalizeDepsPlugin()

**기술적**: node_modules의 모든 의존성을 외부로 표시하여 출력에 번들링되는 것을 방지하는 Vite 플러그인.

**평이한 설명**: 여행을 위해 짐을 싸는 것을 상상해보세요 - 이 플러그인은 "호텔 가구를 가방에 넣지 마세요, 도착하면 거기 있을 거예요"라고 말합니다. Node 모듈은 Electron 환경에서 사용 가능할 것이므로 번들에 넣을 필요가 없습니다.

**사용 이유**: better-sqlite3 같은 네이티브 Node.js 모듈은 Vite로 번들링할 수 없습니다. Node.js가 런타임에 로드하는 별도 파일로 남아 있어야 합니다.

#### rollupOptions.input

**기술적**: 빌드의 진입점 파일을 지정하는 Rollup(Vite가 내부적으로 사용하는 번들러)에 전달되는 설정.

**평이한 설명**: 빌드 시스템에게 "여기서 시작하라"고 알려줍니다 - 미로의 시작을 표시하는 것과 같습니다. 번들러는 이 파일들에서 모든 임포트를 따라 무엇을 포함해야 하는지 결정합니다.

**사용 이유**: 각 프로세스(main, preload, renderer)는 함께 작동하지만 완전히 별개의 프로그램이므로 자체 진입점이 있습니다.

#### resolve.alias

**기술적**: 빌드 시간에 임포트 경로를 변환하는 경로 매핑. 코드가 `import x from '@core/something'`이라고 하면 번들러가 실제 파일 경로로 다시 작성합니다.

**평이한 설명**: 전화에 바로가기를 설정하는 것과 같습니다 - 매번 전체 주소를 입력하는 대신 별명만 입력하면 됩니다. `@core`는 `../../core`보다 쉽고 파일이 이동해도 깨지지 않습니다.

**사용 이유**:
- 더 깔끔한 임포트 (`../../../core/fsrs` 대신 `@core/fsrs`)
- 파일 구조가 변경되어도 임포트가 깨지지 않음
- 아키텍처 경계 강제 (렌더러가 실수로 `@main`에서 임포트할 수 없음)

#### 프리로드 스크립트 (Preload Script)

**기술적**: 웹 콘텐츠가 로드되기 전에 격리된 컨텍스트에서 실행되며, contextIsolation을 통해 제한된 Node.js/Electron API 세트에 액세스할 수 있는 스크립트.

**평이한 설명**: 두 국가 사이의 안전한 대사관과 같습니다. 메인 프로세스(Node.js)는 완전한 권한을 가지지만 직접 노출하기에는 위험합니다. 렌더러(브라우저)는 안전하지만 제한적입니다. 프리로드 스크립트는 특정하고 안전한 작업만 허용되는 통제된 검문소 역할을 합니다.

**사용 이유**: 보안. 프리로드 격리 없이는 렌더러의 크로스 사이트 스크립팅(XSS) 취약점이 Node.js API를 통해 공격자에게 사용자 컴퓨터에 대한 전체 액세스를 줄 수 있습니다.

---

### 변경 이력

#### 2026-01-05 - 초기 문서화
- **변경 내용**: 기존 설정에 대한 내러티브 문서 생성
- **이유**: 빌드 아키텍처에 대한 팀 이해 가능하게 함
- **영향**: 개발자가 이제 빌드가 왜 이렇게 구조화되어 있는지 이해할 수 있음

#### 초기 구현 (프로젝트 설정)
- **변경 내용**: 경로 별칭이 있는 3-프로세스 Electron-Vite 설정 생성
- **이유**: LOGOS는 안전한 IPC 통신과 React UI가 있는 데스크톱 애플리케이션 필요
- **영향**: 전체 애플리케이션을 위한 빌드 기반 확립

---

*이 문서는 `electron.vite.config.ts`를 반영합니다*

---

## 5. Playwright E2E 테스트 설정 (Playwright E2E Test Configuration)

> **최종 업데이트**: 2026-01-05
> **코드 위치**: `playwright.config.ts`
> **상태**: 활성

---

### 컨텍스트 및 목적 (Context & Purpose)

이 설정 파일은 Playwright(엔드 투 엔드 테스팅 프레임워크)가 LOGOS Electron 데스크톱 애플리케이션에 대해 자동화된 테스트를 실행하는 방법을 정의합니다. 단위 테스트가 개별 함수가 격리되어 올바르게 작동하는지 확인하는 반면, E2E 테스트는 사용자 관점에서 전체 애플리케이션이 올바르게 작동하는지 확인합니다 - 버튼 클릭, 양식 작성, 화면 간 탐색, 예상 결과 확인.

**비즈니스 요구사항**: LOGOS는 사용자 경험이 가장 중요한 언어 학습 애플리케이션입니다. 사용자는 앱을 시작하고, 학습 세션을 시작하고, 진행 상황을 보고, 적응형 학습 기능과 원활하게 상호작용할 수 있어야 합니다. E2E 테스트는 단위 테스트가 놓치는 통합 버그를 잡아냅니다 - 개별 컴포넌트가 혼자서는 잘 작동하지만 결합되면 깨지는 상황. E2E 테스트 없이는 릴리스가 단위 테스트가 전혀 감지하지 못한 완전히 작동하지 않는 사용자 플로우와 함께 출시될 수 있습니다.

**사용 시점**:
- 모든 사용자 여정이 올바르게 작동하는지 확인하기 위해 새 버전 출시 전
- 아무것도 깨지지 않았는지 확인하기 위해 중요한 UI 변경 후
- 자동화된 품질 게이트를 위한 CI/CD 파이프라인 중
- 완전한 애플리케이션 컨텍스트에서만 발생하는 사용자 보고 버그 진단 시

---

### 미시적 규모: 직접적 관계 (Microscale: Direct Relationships)

#### 의존성 (이것이 필요로 하는 것)
- `@playwright/test`: `defineConfig`와 `devices` 제공 - 핵심 테스팅 프레임워크와 장치 시뮬레이션 기능
- E2E 테스트 디렉토리 (`./e2e`): `.e2e.ts` 확장자를 가진 모든 E2E 테스트 파일이 있는 곳
- 빌드된 Electron 애플리케이션: 테스트는 소스 코드가 아닌 컴파일된 애플리케이션에 대해 실행

#### 종속자 (이것을 필요로 하는 것)
- `package.json`: 이 설정을 읽는 Playwright를 호출하는 `test:e2e` 같은 스크립트 정의
- `e2e/**/*.e2e.ts`의 모든 E2E 테스트 파일: `testMatch` 패턴을 기반으로 발견되고 실행됨
- CI/CD 파이프라인: E2E 테스트를 실행하고 `CI` 환경 변수 설정을 존중하는 자동화 시스템

#### 다른 테스트 설정과의 관계
- `vitest.config.ts`: 격리된 함수와 알고리즘에 대한 **단위 테스트** 처리
- `playwright.config.ts` (이 파일): 전체 애플리케이션 사용자 여정에 대한 **E2E 테스트** 처리

이들은 상호보완적입니다 - 단위 테스트는 빠르고 세분화되어 있고, E2E 테스트는 느리지만 통합 문제를 잡아냅니다.

#### 데이터 흐름
```
개발자/CI가 Playwright 실행
    --> Playwright가 이 설정 파일 로드
    --> Electron 애플리케이션 실행
    --> **/*.e2e.ts 패턴과 일치하는 테스트 발견
    --> 순차적으로 테스트 실행 (단일 워커)
    --> 실패 시 스크린샷/비디오 캡처
    --> list와 HTML 보고서 생성
    --> CI 통과/실패를 위한 종료 코드 반환
```

---

### 거시적 규모: 시스템 통합 (Macroscale: System Integration)

#### 아키텍처 레이어

이 설정은 **품질 보증 인프라 레이어**에 위치하며, 특히 테스팅 피라미드의 가장 높은 수준입니다:

```
테스팅 피라미드 (LOGOS):
========================

        /\
       /  \
      /E2E \    <-- playwright.config.ts (현재 위치)
     /------\       전체 애플리케이션 테스트
    /        \
   /  Integ.  \     서비스 수준 통합 테스트
  /------------\
 /              \
/   Unit Tests   \  <-- vitest.config.ts
/________________\      핵심 알고리즘 테스트

빌드 인프라:
- electron.vite.config.ts (E2E 테스트가 검증하는 앱 빌드)
- vitest.config.ts (형제 - 단위 테스트)
```

#### 큰 그림의 영향

**이 설정이 검증을 가능하게 하는 것:**

1. **애플리케이션 실행**: Electron이 충돌 없이 시작되고 윈도우가 나타남
2. **탐색 작동**: 사용자가 화면 간 이동 가능 (온보딩, 학습, 분석)
3. **학습 세션 기능**: 사용자가 세션 시작, 질문 답변, 피드백 수신 가능
4. **데이터 지속**: 진행 상황이 세션 간에 저장되고 올바르게 표시됨
5. **UI 올바르게 응답**: 버튼이 예상 동작 트리거, 양식이 입력 검증

#### 중요 경로 분석

**중요도 수준**: 높음 (릴리스 품질 게이트)

- **이것이 실패하면**: E2E 테스트를 실행할 수 없어 릴리스 전 최종 품질 검사가 제거됨
- **잘못 설정되면**: 테스트가 깨진 빌드에서 통과하거나(거짓 신뢰) 작동하는 빌드에서 실패할 수 있음(배포 지연)
- **실패 영향**: 깨진 사용자 플로우가 있는 릴리스가 출시될 수 있어 사용자 신뢰와 유지에 손상

#### 왜 Electron 전용 설정인가?

웹 애플리케이션과 달리 Electron 앱은 고유한 테스팅 도전을 제시합니다:

1. **데스크톱 윈도우 관리**: 테스트가 브라우저 탭이 아닌 네이티브 윈도우를 실행하고 제어해야 함
2. **IPC 통신**: 많은 기능이 메인과 렌더러 프로세스 간 조정 필요
3. **순차 실행 필요**: Electron의 단일 윈도우 특성은 테스트가 병렬로 실행될 수 없음을 의미
4. **더 긴 타임아웃 필요**: 데스크톱 앱 시작이 웹 페이지 로딩보다 느림

이것이 설정이 `workers: 1`과 `fullyParallel: false`를 지정하는 이유입니다 - Electron 테스트를 병렬로 실행하려고 하면 윈도우 충돌과 레이스 컨디션이 발생합니다.

---

### 기술 개념 (평이한 설명)

#### testDir: './e2e'

**기술적**: Playwright가 테스트 파일을 검색할 루트 디렉토리를 지정합니다.

**평이한 설명**: "`e2e` 폴더에서 테스트를 찾아라" - 이것은 엔드 투 엔드 테스트를 `src/`의 단위 테스트와 분리하여 명확한 조직 경계를 유지합니다.

**사용 이유**: 관심사의 분리. E2E 테스트는 단위 테스트와 다른 의존성, 패턴, 실행 특성을 가집니다.

#### fullyParallel: false

**기술적**: 여러 워커에서 테스트 파일을 동시에 실행하는 Playwright의 기능을 비활성화합니다.

**평이한 설명**: "한 번에 하나씩 테스트를 실행하라, 모두 한꺼번에가 아니라." 상점의 단일 계산대처럼 - 느리지만 질서정연합니다. Electron 앱의 경우 테스트를 병렬로 실행하면 여러 앱 윈도우가 제어권을 놓고 싸웁니다.

**사용 이유**: Electron 데스크톱 애플리케이션은 일반적으로 하나의 메인 윈도우가 있는 하나의 인스턴스를 가집니다. 병렬 테스트는 혼란을 만듭니다 - 여러 윈도우, 충돌하는 상태, 재현 불가능한 실패.

#### forbidOnly: !!process.env.CI

**기술적**: CI 환경에서 테스트에 `.only()` 수정자(해당 테스트로만 실행을 제한)가 있으면 테스트 실행을 실패시킵니다.

**평이한 설명**: 개발 중에 단일 테스트에 집중하기 위해 `.only()`를 사용할 수 있습니다. 이 설정은 그것을 커밋하고 CI에서 다른 모든 테스트를 건너뛰는 것을 실수로 방지합니다. `!!`는 CI 환경 변수를 불린으로 변환합니다.

**사용 이유**: 인적 오류에 대한 안전망. 커밋 전에 `.only()`를 제거하는 것을 잊기 쉽고, 그러면 거짓 신뢰를 줍니다(CI가 하나의 테스트만 실행하면서 "통과").

#### retries: process.env.CI ? 2 : 0

**기술적**: CI에서 실패로 표시하기 전에 실패한 테스트를 최대 2번까지 자동으로 재시도합니다. 로컬에서는 재시도 없음.

**평이한 설명**: "자동화된 파이프라인에서는 불안정한 테스트에 두 번째(그리고 세 번째) 기회를 주어라. 개발자가 로컬에서 테스트를 실행할 때는 즉시 실패하여 문제를 바로 볼 수 있게 하라."

**사용 이유**: E2E 테스트는 타이밍 문제, 네트워크 문제, 시스템 부하로 인해 불안정할 수 있습니다. 재시도는 개발자에게서 실제 버그를 숨기지 않으면서 CI에서 거짓 음성을 줄입니다.

#### workers: 1

**기술적**: Playwright를 테스트 실행을 위한 단일 워커 프로세스로 제한합니다.

**평이한 설명**: "한 번에 하나의 테스트만 실행한다, 절대로." `fullyParallel: false`보다 더 엄격합니다 - 이것은 Playwright 프로세스가 하나뿐이고, 따라서 Electron 앱 인스턴스도 하나뿐임을 보장합니다.

**사용 이유**: Electron 제약. 애플리케이션은 자체 상태, 윈도우, 데이터베이스를 관리합니다. 여러 인스턴스는 상태를 손상시키고 의미 없는 테스트 결과를 생성합니다.

#### reporter: [['list'], ['html', { open: 'never' }]]

**기술적**: 두 가지 보고서 형식을 설정합니다: 터미널로 실시간 list 출력, 자동으로 열리지 않는 HTML 보고서 파일.

**평이한 설명**:
- `list`: 터미널에서 실행되는 대로 테스트 결과 표시 - 즉각적인 피드백
- `html`: 나중에 탐색할 수 있는 상세 보고서 웹페이지 생성, 하지만 자동으로 열어서 방해하지 않음

**사용 이유**: 다른 때에 다른 필요. List 형식은 진행 상황을 지켜보기에 좋고; HTML은 스크린샷과 트레이스로 실패를 조사하기에 좋습니다.

#### timeout: 60000 (60초)

**기술적**: 단일 테스트가 타임아웃 실패로 종료되기 전에 실행할 수 있는 최대 시간(밀리초).

**평이한 설명**: "테스트가 60초 이상 걸리면 뭔가 잘못된 것이다 - 종료하라." 농구의 샷 클록처럼. E2E 테스트는 단위 테스트보다 느린 앱 시작을 포함하지만 60초는 여전히 넉넉합니다.

**사용 이유**: Electron 앱 시작은 몇 초가 걸릴 수 있고, 일부 테스트는 애니메이션이나 비동기 작업을 기다릴 수 있습니다. 60초는 이를 수용하면서도 멈춘 테스트를 잡아냅니다.

#### expect.timeout: 10000 (10초)

**기술적**: 개별 단언(expect 문)이 실패 전에 해결되는 최대 시간.

**평이한 설명**: "화면에 무언가가 나타났는지 확인할 때, 포기하기 전에 최대 10초까지 기다려라." 이것은 전체 테스트 타임아웃과 별개로 단언별입니다.

**사용 이유**: UI 요소는 비동기 데이터 로딩이나 애니메이션으로 인해 렌더링에 시간이 걸릴 수 있습니다. 10초는 인내심 있지만 터무니없이 길지는 않습니다.

#### trace: 'on-first-retry'

**기술적**: 테스트가 실패하고 재시도될 때만 상세 실행 트레이스를 기록합니다.

**평이한 설명**: 트레이스는 비행기의 블랙박스 녹음기와 같습니다 - 모든 동작, 스크린샷, 네트워크 요청을 캡처합니다. 모든 테스트에 대해 트레이스를 생성하는 것은 낭비이므로 뭔가 잘못되어 조사가 필요할 때만 캡처합니다.

**사용 이유**: 디버깅 효율성. 테스트가 실패하면 트레이스가 정확히 무슨 일이 일어났는지 단계별 재생을 제공합니다.

#### screenshot: 'only-on-failure'

**기술적**: 테스트가 실패할 때만 애플리케이션 윈도우의 스크린샷을 자동으로 캡처합니다.

**평이한 설명**: "범죄 현장 사진을 찍어라." 일이 잘못되면 그 순간 화면이 어떻게 보였는지 보고 싶습니다.

**사용 이유**: 실패 조사. 스크린샷은 종종 문제를 즉시 드러냅니다(오류 대화상자, 잘못된 페이지, 누락된 요소).

#### video: 'retain-on-failure'

**기술적**: 전체 테스트 실행의 비디오를 녹화하지만 테스트가 실패할 때만 저장합니다.

**평이한 설명**: 사건이 발생하지 않으면 자동 삭제되는 보안 카메라 영상과 같습니다. 비디오는 큰 파일이므로 실패 디버깅에 도움이 될 수 있는 것만 보관합니다.

**사용 이유**: 복잡한 실패의 경우 스크린샷은 최종 상태를 보여주지만 비디오는 어떻게 거기에 도달했는지 보여줍니다 - 타이밍 관련 버그를 재현하는 데 매우 귀중합니다.

#### projects: [{ name: 'electron', testMatch: '**/*.e2e.ts' }]

**기술적**: `.e2e.ts` 패턴과 일치하는 모든 파일을 실행하는 "electron"이라는 단일 테스트 프로젝트를 정의합니다.

**평이한 설명**: Playwright의 "프로젝트"는 다른 브라우저나 설정을 나타낼 수 있습니다. LOGOS는 하나만 있습니다: Electron. `**/*.e2e.ts` 패턴은 "모든 하위 디렉토리에서 `.e2e.ts`로 끝나는 모든 파일"을 의미합니다.

**사용 이유**: 미래 확장을 허용하면서 설정을 단순하게 유지합니다. 모바일이나 웹 버전이 추가되면 다른 설정을 가진 추가 프로젝트가 됩니다.

---

### 설정 결정 및 근거 (Configuration Decisions & Rationale)

#### 왜 E2E를 단위 테스트와 분리하는가?

| 측면 | 단위 테스트 (Vitest) | E2E 테스트 (Playwright) |
|--------|--------------------|-----------------------|
| 테스트 대상 | 개별 함수 | 완전한 사용자 여정 |
| 속도 | 테스트당 밀리초 | 테스트당 초 |
| 의존성 | 없음 (순수 로직) | 빌드된 애플리케이션, OS |
| 병렬성 | 예 (격리됨) | 아니오 (공유 앱 상태) |
| 위치 | `src/**/*.test.ts` | `e2e/**/*.e2e.ts` |

분리해두면 각각이 타협 없이 최적의 설정을 사용할 수 있습니다.

#### 왜 이렇게 긴 타임아웃인가?

단위 테스트(10초 타임아웃)와 달리 E2E 테스트는 60초를 허용합니다:
1. **앱 시작 시간**: Electron 초기화에 2-5초 소요
2. **데이터베이스 초기화**: 첫 실행 시 Prisma/SQLite 설정
3. **UI 렌더링**: React 컴포넌트 하이드레이션과 데이터 로딩
4. **애니메이션 완료**: 전환이 끝나기를 기다림

#### 왜 실패 시에만 비디오/스크린샷을 녹화하는가?

저장 공간과 성능. 단일 비디오 파일은 10-50MB가 될 수 있습니다. 50개 테스트를 실행하면 기가바이트의 비디오가 생성됩니다. 실패 증거만 보관함으로써 저장 공간 폭발 없이 디버깅 이점을 얻습니다.

---

### 변경 이력

#### 2026-01-05 - 초기 문서화
- **변경 내용**: playwright.config.ts에 대한 내러티브 문서 생성
- **이유**: E2E 테스팅 인프라를 설명하는 섀도우 문서 수립
- **영향**: 미래 개발자가 왜 Electron E2E 테스팅이 일반적인 웹 테스팅과 다르게 설정되는지 이해할 수 있음

---

*이 문서는 `playwright.config.ts`를 반영합니다*

---

## 6. Electron 테스트 헬퍼 모듈 (Electron Test Helper Module)

> **최종 업데이트**: 2026-01-05
> **코드 위치**: `e2e/electron.helper.ts`
> **상태**: 활성

---

### 컨텍스트 및 목적 (Context & Purpose)

이 모듈은 Playwright(브라우저 자동화 프레임워크)와 Electron(데스크톱 애플리케이션 프레임워크) 사이의 간극을 메우기 위해 존재합니다. 표준 Playwright는 브라우저에서 웹 애플리케이션을 테스트하도록 설계되었지만, LOGOS는 Electron 데스크톱 애플리케이션입니다 - 이는 자동화된 테스트 중에 실행, 제어, 상호작용을 위해 특별한 처리가 필요합니다.

**비즈니스 요구사항**: 언어 학습 애플리케이션의 품질 보증은 중요합니다. 사용자는 학습 진행 상황, 어휘 데이터, 학습 일정에 대해 앱을 신뢰합니다. 자동화된 엔드 투 엔드 테스트는 코드가 프로덕션에 도달하기 전에 사용자 관점에서 애플리케이션이 올바르게 작동하는지 확인합니다 - 버튼 클릭, 양식 작성, 화면 간 탐색.

**사용 시점**: 이 헬퍼는 모든 E2E 테스트 스위트 시작 시 호출됩니다. 제어된 테스트 환경에서 LOGOS 애플리케이션을 실행하고, 일반적인 테스트 작업을 위한 유틸리티를 제공하며, 테스트 완료 후 깔끔한 종료를 보장합니다.

---

### 미시적 규모: 직접적 관계 (Microscale: Direct Relationships)

#### 의존성 (이것이 필요로 하는 것)

- `playwright` (외부 패키지): `_electron` 런처와 `Page`/`ElectronApplication` 타입 제공 - Electron 앱 자동화를 위한 핵심 인프라
- `path` (Node.js 내장): 컴파일된 애플리케이션 진입점을 찾기 위한 크로스 플랫폼 파일 경로 구성
- `out/main/index.js`: 컴파일된 Electron 메인 프로세스 진입점 - 테스트 실행 시 실행되는 것

#### 종속자 (이것을 필요로 하는 것)

- **E2E 테스트 파일** (계획/미래): 모든 E2E 테스트 스펙이 이 모듈에서 `launchApp()`, `closeApp()` 및 기타 유틸리티를 임포트
- **CI/CD 파이프라인**: 자동화된 테스트 워크플로우가 배포 전에 전체 애플리케이션 테스트를 실행하기 위해 이 모듈 호출

#### 데이터 흐름

```
테스트 스위트 시작
       |
       v
launchApp() 호출
       |
       v
electron.launch()가 테스트 환경 변수와 함께 LOGOS 앱 생성
       |
       v
앱이 첫 번째 윈도우 열기 (src/main/index.ts를 통한 BrowserWindow)
       |
       v
waitForLoadState('domcontentloaded')가 UI 준비 확인
       |
       v
Page 객체를 사용하여 UI와 상호작용하며 테스트 실행
       |
       v
cleanupTestData()가 데이터베이스에서 테스트 아티팩트 제거
       |
       v
closeApp()가 Electron 프로세스 종료
```

---

### 거시적 규모: 시스템 통합 (Macroscale: System Integration)

#### 아키텍처 레이어

이 모듈은 메인 애플리케이션 아키텍처와 병렬로 존재하지만 그 외부에 있는 **테스팅 인프라 레이어**에 위치합니다:

```
+--------------------------------------------------+
|  테스팅 인프라 (현재 위치)                        |
|  +-----------------+  +------------------------+ |
|  | electron.helper |->| Playwright Test Runner | |
|  +-----------------+  +------------------------+ |
+--------------------------------------------------+
          |
          | 실행 및 제어
          v
+--------------------------------------------------+
|  LOGOS 애플리케이션                              |
|  +------------+  +-------------+  +-----------+  |
|  | Main       |->| Preload     |->| Renderer  |  |
|  | Process    |  | Bridge      |  | (React)   |  |
|  +------------+  +-------------+  +-----------+  |
+--------------------------------------------------+
```

헬퍼는 **테스트 하네스(test harness)** 역할을 합니다 - 전체 LOGOS 애플리케이션을 래핑하고 자동화된 테스트를 위한 제어된 액세스를 제공합니다.

#### 큰 그림의 영향

이 모듈은 LOGOS의 테스팅 전략에 기초적입니다. 다음을 가능하게 합니다:

- **회귀 테스트**: 새 코드 변경이 기존 기능을 깨뜨리지 않는지 자동으로 확인
- **사용자 여정 검증**: "목표 생성, 어휘 추가, 세션 학습"과 같은 완전한 워크플로우 테스트
- **크로스 플랫폼 신뢰**: Electron 앱이 Windows, macOS, Linux에서 올바르게 작동하는지 확인
- **지속적 통합**: 중요한 사용자 플로우가 깨지면 배포 차단

**의존성**: 전체 E2E 테스트 스위트가 이 모듈이 올바르게 작동하는 것에 의존합니다. 이것 없이는 사용자 관점에서 전체 애플리케이션 스택을 테스트하는 자동화된 방법이 없습니다.

#### 중요 경로 분석

**중요도 수준**: 높음 (개발 워크플로우용)

- **이것이 실패하면**: E2E 테스트를 실행할 수 없고, CI/CD 파이프라인이 차단되며, 팀이 자동화된 테스트에 대한 신뢰를 잃음
- **실패 모드**: 테스트가 멈추거나, 충돌하거나, 거짓 양성/음성 생성
- **백업**: 수동 테스트 (느리고, 비용이 많이 들고, 오류 발생 가능)

---

### 기술 개념 (평이한 설명)

#### Electron 실행 컨텍스트 (Electron Launch Context)

**기술적**: Electron 앱이 연 첫 번째 브라우저 윈도우를 나타내는 `Page` 객체와 결합된 `ElectronApplication` 인스턴스.

**평이한 설명**: LOGOS 앱을 위한 리모컨처럼 생각하세요. `app`은 전체 애플리케이션을 위한 리모컨이고(닫을 수 있고, 시스템 기능에 액세스할 수 있음), `window`는 화면에 보이는 것을 위한 리모컨입니다(버튼을 클릭하고, 텍스트 필드를 채우고, 표시된 텍스트를 읽을 수 있음).

**사용 이유**: 두 수준의 제어가 모두 필요합니다 - 때때로 테스트는 UI와 상호작용해야 하고, 다른 때는 애플리케이션 수명주기 자체를 제어해야 합니다.

#### 테스트 데이터베이스 격리 (Test Database Isolation)

**기술적**: 헬퍼가 테스트 중에 별도의 SQLite 데이터베이스 파일을 사용하도록 `DATABASE_URL: 'file:./test.db'`를 설정합니다.

**평이한 설명**: 실제 프레젠테이션 보드와 별도인 연습용 화이트보드를 갖는 것과 같습니다. 테스트는 실제 사용자 데이터에 영향을 주지 않고 목표를 생성하고, 어휘를 추가하고, 변경할 수 있습니다. 테스트 후에 이 연습용 보드는 완전히 지울 수 있습니다.

**사용 이유**: 테스트는 **격리**되어야 합니다 - 프로덕션 데이터에 영향을 주면 안 되고, 테스트를 여러 번 실행해도 일관된 결과를 생성해야 합니다. 별도의 데이터베이스를 사용하면 테스트가 실제 사용자 데이터를 방해하지 않습니다.

#### 환경 변수 주입 (Environment Variable Injection)

**기술적**: `process.env`와 병합되어 Electron의 실행 환경을 통해 `NODE_ENV: 'test'`를 전달합니다.

**평이한 설명**: 애플리케이션에 "테스트 모드" 스티커를 붙이는 것과 같습니다. 앱이 이 스티커를 보면 테스트 중임을 알고 약간 다르게 동작할 수 있습니다(분석 비활성화, 인트로 애니메이션 건너뛰기, 테스트 API 키 사용).

**사용 이유**: 애플리케이션은 테스트 중에 다르게 동작해야 할 수 있습니다 - 더 짧은 타임아웃, 외부 서비스 모킹, 속도 제한 비활성화 - 그리고 이 환경 플래그가 그런 조건부 동작을 가능하게 합니다.

#### Data-TestId 셀렉터 (Data-TestId Selectors)

**기술적**: CSS 클래스나 텍스트 콘텐츠 대신 `[data-testid="app-root"]` 셀렉터를 사용하여 요소를 찾습니다.

**평이한 설명**: 시각적 디자인이 변경되어도 절대 변하지 않는 영구적인 이름표를 UI 요소에 붙이는 것과 같습니다. CSS 클래스는 UI를 재설계할 때 변경될 수 있지만, 테스트 ID는 테스트가 요소를 찾는 것을 돕는 것이 유일한 목적이므로 안정적으로 유지됩니다.

**사용 이유**: UI 팀이 스타일링을 변경해도 깨지지 않는 **안정적인 셀렉터**를 만듭니다. 코드와 테스트 사이의 계약은 명시적입니다: "이 요소는 항상 이 테스트 ID를 가질 것입니다."

#### 로드 상태 대기 (Wait for Load State)

**기술적**: `window.waitForLoadState('domcontentloaded')`는 DOM이 완전히 파싱되고 준비될 때까지 테스트 실행을 일시 중지합니다.

**평이한 설명**: 무언가를 클릭하기 전에 웹페이지가 로딩을 완료할 때까지 기다리는 것과 같습니다. 헬퍼는 테스트가 상호작용을 시작하기 전에 앱이 실제로 준비되어 있는지 확인하여, 너무 빨리 실행되는 테스트의 "요소를 찾을 수 없음" 오류를 방지합니다.

**사용 이유**: Electron 앱에는 시작 시퀀스가 있습니다 - 프로세스 실행, 윈도우 생성, HTML 로드, JavaScript 실행, React 렌더링. 테스트는 UI와 안정적으로 상호작용하기 전에 이 시퀀스가 완료될 때까지 기다려야 합니다.

#### LOGOS API 브릿지 검사 (LOGOS API Bridge Check)

**기술적**: `isLogosAPIAvailable()` 함수가 렌더러 컨텍스트에서 `window.logos`가 정의되어 있는지 확인합니다.

**평이한 설명**: 전화를 걸기 전에 전화선이 연결되어 있는지 확인하는 것과 같습니다. `window.logos` 객체는 UI가 데이터베이스 및 백엔드 로직과 통신하는 방법입니다. 거기에 없으면 아무것도 작동하지 않습니다.

**사용 이유**: 프리로드 스크립트가 렌더러에 `logos` API를 주입합니다. 이 검사는 테스트가 사용하기 전에 프론트엔드와 백엔드 사이의 보안 브릿지가 확립되었는지 확인합니다.

---

### 주요 함수 설명

#### launchApp()

**목적**: 테스트 스위트를 위해 LOGOS 애플리케이션을 새로 시작

**반환**: 앱 컨트롤러와 윈도우 페이지 객체를 모두 포함하는 `ElectronTestContext`

**핵심 세부사항**: 격리된 데이터베이스와 테스트 모드 플래그로 테스트 환경 설정

#### closeApp(context)

**목적**: 테스트 완료 후 Electron 애플리케이션을 우아하게 종료

**핵심 세부사항**: 테스트 스위트 종료 후 좀비 프로세스가 남아 있지 않도록 보장

#### waitForAppReady(window)

**목적**: React가 마운트되고 애플리케이션이 완전히 상호작용 가능할 때까지 대기

**핵심 세부사항**: 30초 타임아웃 사용 - 느린 CI 머신에 충분히 넉넉하고, 무언가 진짜 깨졌을 때 빨리 실패할 만큼 빠름

#### navigateTo(window, route)

**목적**: 메뉴를 클릭하지 않고 앱의 다른 페이지/경로로 프로그래밍 방식으로 탐색

**핵심 세부사항**: React Router의 history API를 직접 사용하여 UI 상호작용 없이 탐색 시뮬레이션

#### createTestGoal(window, name, targetLanguage, nativeLanguage)

**목적**: 테스트 사용자가 하듯이 UI를 통해 학습 목표 생성

**핵심 세부사항**: 테스트 ID를 사용하여 양식 요소와 상호작용하며, 목표가 존재해야 하는 모든 테스트를 위한 재사용 가능한 "테스트 픽스처" 제공

#### cleanupTestData(window)

**목적**: 테스트 간 깨끗한 상태를 보장하기 위해 데이터베이스에서 모든 테스트 데이터 삭제

**핵심 세부사항**: 렌더러 컨텍스트에서 `window.logos` API를 직접 사용하여 대량 삭제 수행

---

### 변경 이력

#### 2026-01-05 - 초기 구현

- **변경 내용**: 핵심 유틸리티(실행, 종료, 탐색, 목표 생성, 정리)가 있는 Electron 테스트 헬퍼 생성
- **이유**: Playwright를 사용하여 LOGOS Electron 애플리케이션의 E2E 테스트 활성화
- **영향**: 전체 E2E 테스트 스위트를 위한 기반 확립

---

*이 문서는 `e2e/electron.helper.ts`를 반영합니다*

---

## 7. 로고 변환 스크립트 (Logo Conversion Script)

> **최종 업데이트**: 2026-01-05
> **코드 위치**: `scripts/convert-logo.js`
> **상태**: 활성

---

### 컨텍스트 및 목적 (Context & Purpose)

이 스크립트는 디자인과 배포 사이의 간극을 메우기 위해 존재합니다. SVG 형식은 소스 로고에 이상적이지만(무한히 확장 가능하고, 편집하기 쉬움), Electron과 운영 체제는 애플리케이션 아이콘을 위해 특정 형식과 크기의 래스터화된 이미지를 필요로 합니다.

**비즈니스 요구사항**: LOGOS는 브랜드 아이덴티티를 확립하기 위해 모든 플랫폼(Windows, macOS, Linux)에서 전문적이고 선명한 아이콘이 필요합니다. 사용자는 작업 표시줄, 독, 시작 메뉴, 데스크톱 바로가기에서 아이콘으로 애플리케이션을 식별합니다. 적절한 아이콘 변환 없이는 앱이 일반적이거나 깨진 아이콘을 표시하여 비전문적으로 보입니다.

**사용 시점**: 이 스크립트는 배포를 위해 Electron 애플리케이션을 패키징하기 전 빌드 준비 단계에서 수동으로 실행됩니다. 자동화된 빌드 파이프라인의 일부가 아닙니다 - 소스 로고(`logo.svg`)가 변경될 때만 실행하면 됩니다.

---

### 미시적 규모: 직접적 관계 (Microscale: Direct Relationships)

#### 의존성 (이것이 필요로 하는 것)

- `src/renderer/assets/logo.svg`: LOGOS 브랜드 아이덴티티를 특징으로 하는 소스 SVG 로고 (언어 연결을 나타내는 네트워크 노드와 람다 기호가 있는 그라디언트 원)
- `sharp` (npm 패키지): **이미지 처리 라이브러리** (이미지 형식 간 변환이 가능한 고성능 Node.js 모듈) - SVG에서 PNG로의 변환과 크기 조정 처리
- `png-to-ico` (npm 패키지): **ICO 파일 생성기** (여러 PNG 이미지를 단일 Windows ICO 파일로 변환) - 다중 해상도 Windows 아이콘 생성
- `fs` (Node.js 내장): **파일 시스템 모듈** (디스크에서 파일 읽기 및 쓰기)
- `path` (Node.js 내장): **경로 유틸리티** (크로스 플랫폼 파일 경로를 올바르게 구성)

#### 종속자 (이것을 필요로 하는 것)

- `electron-builder.yml`: 모든 플랫폼 빌드를 위해 생성된 `resources/icon.png` 참조
- `nsis` 인스톨러 설정: 인스톨러 UI를 위해 생성된 아이콘 사용 (인스톨러 아이콘, 언인스톨러 아이콘, 헤더 아이콘)
- `win.icon`, `mac.icon`, `linux.icon`: 모든 플랫폼 설정이 생성된 아이콘 파일을 가리킴
- Linux 빌드: 모든 크기 변형을 포함하는 `resources/icons/` 디렉토리 사용

#### 데이터 흐름

```
logo.svg (소스)
    |
    v
[sharp 라이브러리가 SVG 버퍼 읽기]
    |
    v
[8개 PNG 크기 생성: 16, 32, 48, 64, 128, 256, 512, 1024]
    |
    +---> resources/icons/{size}x{size}.png (개별 파일)
    |
    +---> resources/icon.png (256x256 메인 아이콘)
    |
    v
[png-to-ico가 16, 32, 48, 64, 128, 256 크기 결합]
    |
    v
resources/icon.ico (Windows 다중 해상도 아이콘)
```

---

### 거시적 규모: 시스템 통합 (Macroscale: System Integration)

#### 아키텍처 레이어

이 스크립트는 프로젝트 아키텍처의 **빌드 도구 레이어**에 위치합니다:

- **Layer 1**: 소스 자산 (`src/renderer/assets/logo.svg`) - 디자인 파일
- **Layer 2**: 빌드 스크립트 (`scripts/convert-logo.js`) - 현재 위치
- **Layer 3**: 생성된 리소스 (`resources/`) - 빌드 아티팩트
- **Layer 4**: Electron Builder (`electron-builder.yml`) - 패키징 설정
- **Layer 5**: 배포 가능한 패키지 (`release/`) - 최종 출력

#### 큰 그림의 영향

이 스크립트는 LOGOS 브랜딩을 위한 **자산 파이프라인**입니다. 다음을 가능하게 합니다:

1. **Windows 배포**: Windows가 작업 표시줄(16px), 타이틀 바(32px), Alt+Tab(48px), 데스크톱 바로가기(256px)에 적절한 크기를 표시할 수 있도록 여러 해상도를 포함하는 `icon.ico` 생성

2. **macOS 배포**: Retina 디스플레이, 독 아이콘, Finder 미리보기를 위한 고해상도 `icon.png` 제공

3. **Linux 배포**: Linux 데스크톱 환경이 freedesktop.org 아이콘 테마에 대해 기대하는 `resources/icons/` 디렉토리 구조 생성

4. **인스톨러 브랜딩**: NSIS 인스톨러가 UI에 이 아이콘을 사용하여 설치 경험을 애플리케이션 브랜딩과 일관되게 만듦

**이 스크립트 없이**: electron-builder가 제대로 브랜딩된 인스톨러를 만들지 못하거나, 폴백 일반 아이콘을 사용하여 LOGOS의 전문적인 외관이 손상됩니다.

#### 중요 경로 분석

**중요도 수준**: 중간-높음 (빌드 시간 중요)

- **이것이 실패하면**: 배포 빌드가 적절한 브랜딩으로 진행할 수 없음
- **실패 모드**:
  - sharp/png-to-ico 패키지 누락: 모듈을 찾을 수 없음으로 스크립트 충돌
  - 소스 SVG 누락: 파일을 찾을 수 없음으로 스크립트 충돌
  - 손상된 SVG: sharp가 파싱 실패, 아이콘 생성 안 됨
  - 디스크 공간 부족: 쓰기 작업이 조용히 또는 부분적으로 실패
- **폴백 동작**: 스크립트에 ICO 생성을 위한 내장 폴백이 있음 - `png-to-ico`가 실패하면 256x256 PNG를 `icon.ico`로 복사 (현대 Windows에서 작동하지만 다중 해상도 지원 없음)
- **복구**: 근본 문제 수정 후 스크립트 재실행

---

### 기술 개념 (평이한 설명)

#### SVG (Scalable Vector Graphics, 확장 가능한 벡터 그래픽)

**기술적**: 픽셀이 아닌 수학적으로 도형을 설명하는 XML 기반 벡터 이미지 형식.

**평이한 설명**: 사진이 아닌 그리기 레시피와 같습니다. 컴퓨터가 어떤 크기로든 다시 그리기 때문에 무한히 확대해도 흐릿해지지 않습니다.

**사용 이유**: 로고 소스가 SVG이므로 디자이너가 쉽게 편집할 수 있고 품질 손실 없이 모든 해상도로 변환할 수 있습니다.

#### 래스터화 (Rasterization)

**기술적**: 벡터 그래픽을 특정 해상도의 비트맵(픽셀 그리드)으로 변환하는 프로세스.

**평이한 설명**: "레시피"(SVG)를 가져다가 실제로 고정 크기의 "사진"(PNG)으로 "요리"하는 것. 래스터화되면 픽셀이 보이지 않고는 확대할 수 없습니다.

**사용 이유**: 운영 체제는 고정 크기로 표시되기 때문에 애플리케이션 아이콘에 래스터화된 이미지를 필요로 합니다.

#### ICO 형식 (다중 해상도 아이콘)

**기술적**: 다른 해상도의 여러 PNG 이미지를 단일 파일에 번들로 묶는 Windows 전용 컨테이너 형식.

**평이한 설명**: 같은 그림을 다른 크기로 담고 있는 러시아 중첩 인형과 같습니다. Windows는 아이콘을 표시해야 하는 위치에 따라 적절한 크기를 선택합니다.

**사용 이유**: Windows는 다른 컨텍스트(작업 표시줄 vs 데스크톱)에 다른 아이콘 크기가 필요하고, ICO는 모든 크기를 하나의 파일로 제공할 수 있습니다.

#### Sharp 라이브러리

**기술적**: libvips를 기반으로 구축된 고성능 Node.js 이미지 처리 라이브러리로, 이미지 크기 조정, 변환, 조작이 가능합니다.

**평이한 설명**: 코드를 통해 자동으로 실행되는 전문 사진 편집 도구. 대부분의 대안보다 훨씬 빠르게 이미지 크기를 조정하고 변환할 수 있습니다.

**사용 이유**: Sharp는 Node.js 이미지 처리의 표준 - 빠르고, 안정적이며, SVG 입력을 잘 처리합니다.

#### Buffer (Node.js)

**기술적**: 디스크에 쓰기 전에 파일 내용을 처리하기 위해 사용되는 Node.js 메모리의 원시 바이너리 데이터 컨테이너.

**평이한 설명**: 메모리에 파일의 원시 바이트를 보관하는 클립보드와 같습니다. 스크립트는 SVG를 버퍼로 읽고, 처리하고, 결과를 씁니다.

**사용 이유**: 특히 같은 소스에서 여러 크기를 생성할 때 반복적으로 파일을 읽고 쓰는 것보다 버퍼로 작업하는 것이 더 효율적입니다.

---

### 플랫폼별 아이콘 요구사항

#### Windows
- **ICO 파일**: 16x16, 32x32, 48x48, 64x64, 128x128, 256x256 크기 포함 필수
- **사용처**: 작업 표시줄, 시작 메뉴, 데스크톱 바로가기, 인스톨러 UI
- **형식 특이점**: ICO는 이미지 형식 자체가 아닌 컨테이너

#### macOS
- **ICNS 또는 PNG**: 고해상도 PNG(512x512 또는 1024x1024) 사용 가능
- **사용처**: 독, Finder, Spotlight, DMG 인스톨러 배경
- **Retina**: macOS가 Retina 디스플레이에 자동으로 2배 해상도 사용

#### Linux
- **PNG 디렉토리**: freedesktop.org 사양은 여러 PNG 크기의 디렉토리 구조 기대
- **사용처**: 애플리케이션 메뉴, 파일 관리자, 작업 표시줄 (데스크톱 환경에 따라 다름)
- **형식**: 크기별로 명명된 개별 PNG 파일 (예: `256x256.png`)

---

### 변경 이력

#### 2026-01-05 - 초기 문서화

- **변경 내용**: convert-logo.js 스크립트에 대한 내러티브 문서 생성
- **이유**: Shadow Map 방법론은 모든 코드 파일에 대한 문서화 필요
- **영향**: 미래 개발자가 이 빌드 도구의 목적과 컨텍스트를 이해할 수 있음

---

*이 문서는 `scripts/convert-logo.js`를 반영합니다*

---

## 8. 공유 IPC 타입 정의 (Shared IPC Type Definitions)

> **최종 업데이트**: 2026-01-06
> **코드 위치**: `src/shared/types.ts`
> **상태**: 활성

---

### 컨텍스트 및 목적 (Context & Purpose)

이 파일은 LOGOS의 **크로스 프로세스 타입 브릿지**입니다. `src/core/types.ts`가 핵심 알고리즘을 위한 타입을 정의하는 반면, 이 파일은 해당 타입을 렌더러 프로세스에서 사용 가능하게 하고 모든 IPC 관련 타입(요청/응답 페이로드, API 인터페이스, 이벤트 타입)을 정의합니다.

**비즈니스 요구사항**: Electron 애플리케이션에서 렌더러 프로세스(React UI)와 메인 프로세스(Node.js 백엔드)는 완전히 분리되어 있습니다. 런타임 코드를 공유할 수 없습니다 - 각각 별도로 번들됩니다. 그러나 통신을 위해 데이터 형태에 동의해야 합니다. 이 파일은 양측이 참조하는 "계약"으로, 프로세스 경계를 넘어 타입 안전성을 보장합니다.

**사용 시점**:
- IPC 메서드를 호출할 때 렌더러에서 (무엇을 보내고 기대할지 알기 위해)
- IPC 핸들러를 구현할 때 메인 프로세스에서 (요청 검증 및 응답 형성)
- `window.logos` API를 정의할 때 프리로드 스크립트에서
- IPC 동작을 모킹할 때 테스트에서

---

### 미시적 규모: 직접적 관계 (Microscale: Direct Relationships)

#### 의존성 (이것이 필요로 하는 것)

- **`../core/types`**: 모든 핵심 알고리즘 타입 재내보내기
  - IRT 타입: `ItemParameter`, `ThetaEstimate`, `IRTModel`
  - PMI 타입: `PMIResult`, `PMIPair`, `DifficultyMapping`
  - FSRS 타입: `FSRSCard`, `FSRSParameters`, `FSRSRating` 등
  - 숙달 타입: `MasteryStage`, `MasteryState`, `MasteryResponse`
  - 태스크 타입: `TaskType`, `TaskFormat`, `TaskSpec`, `TaskContent`, `Task`
  - 세션 타입: `SessionMode`, `SessionConfig`, `SessionState`, `SessionSummary`
  - 우선순위 타입: `FREMetrics`, `PriorityCalculation`
  - 병목 타입: `ComponentType`, `BottleneckEvidence`, `BottleneckAnalysis`
  - 언어 객체 타입: `LanguageObject`, `LanguageObjectType`
  - 목표 타입: `GoalSpec`, `Domain`, `Modality`
  - 사용자 타입: `User`, `UserThetaProfile`
  - 큐 타입: `LearningQueueItem`
  - 평가 타입: `ResponseEvaluation`, `EvaluationScores`, `ResponseError`
  - 유틸리티 타입: `Result`, `PaginationParams`, `PaginatedResult`, `DateRange`

#### 종속자 (이것을 필요로 하는 것)

**IPC 레이어 (메인 프로세스):**
- `src/main/ipc/contracts.ts`: 타입 안전 핸들러 등록을 위해 `IPCHandlerMap` 임포트
- 모든 `*.ipc.ts` 파일: 요청/응답 타입 임포트
- `src/main/preload.ts`: contextBridge를 위해 `LogosAPI` 임포트

**렌더러 프로세스:**
- `src/renderer/hooks/useLogos.ts`: API 타입 사용
- React 컴포넌트: 상태와 props를 위해 타입 임포트
- `src/renderer/context/AppContext.tsx`: 세션과 사용자 타입 사용

**서비스:**
- 많은 서비스가 core/types에서 직접이 아닌 이 파일을 통해 임포트

#### 데이터 흐름

```
src/core/types.ts
       |
       | (핵심 알고리즘 타입)
       v
src/shared/types.ts
       |
       +---------> 메인 프로세스
       |             - IPC 핸들러가 요청 검증
       |             - 서비스가 도메인 타입 사용
       |
       +---------> 프리로드 스크립트
       |             - window.logos 형태 정의
       |
       +---------> 렌더러 프로세스
                    - 컴포넌트가 props/state에 타입 사용
                    - 훅이 타입화된 데이터 반환
```

---

### 거시적 규모: 시스템 통합 (Macroscale: System Integration)

#### 아키텍처 레이어

이 파일은 아키텍처 경계 사이의 **타입 브릿지**입니다:

```
+----------------------------------------------------------+
| 렌더러 프로세스                                           |
| - React 컴포넌트                                          |
| - shared/types.ts의 타입 사용                             |
| - main/ 또는 core/에서 직접 임포트 불가                   |
+----------------------------------------------------------+
                         |
                         | src/shared/types.ts를 통해
                         | 공유되는 타입
                         v
+----------------------------------------------------------+
| 프리로드 스크립트 (contextBridge)                         |
| - window.logos: LogosAPI 정의                             |
| - API 형태에 공유 타입 사용                               |
+----------------------------------------------------------+
                         |
                         v
+----------------------------------------------------------+
| 메인 프로세스                                             |
| - IPC 핸들러                                              |
| - 서비스                                                  |
| - core/ 및 shared/ 모두에서 임포트 가능                   |
+----------------------------------------------------------+
```

#### 큰 그림의 영향

이 파일은 LOGOS에서 **타입 안전 풀스택 개발**을 가능하게 합니다:

| 기능 | 이 파일이 활성화하는 방법 |
|------------|-------------------------|
| 타입 안전 IPC | `IPCHandlerMap`이 요청/응답 타입 일치 보장 |
| IDE 자동완성 | 렌더러가 사용 가능한 모든 API 메서드와 형태 알음 |
| 리팩토링 안전성 | 타입 변경이 프로세스 간 모든 사용처 업데이트 |
| 문서화 | 타입이 자기 문서화하는 API 사양 역할 |
| 테스팅 | 모의 구현을 타입 검사 가능 |

**이 파일 없이:**
- 렌더러가 모든 IPC 데이터에 `any` 사용
- IPC 불일치의 컴파일 타임 포착 없음
- API 변경이 조용히 렌더러 코드 깨뜨림
- `window.logos` 사용 시 자동완성 없음

#### 중요 경로 분석

**중요도 수준**: 중요 (타입 브릿지)

- **타입이 잘못되면**: 컴파일 오류 대신 런타임 오류
- **타입이 구현과 드리프트하면**: 조용한 데이터 손상
- **재내보내기가 누락되면**: 렌더러가 필요한 타입에 액세스 불가

**유지보수 요구사항**: 이 파일은 `core/types.ts` 및 모든 IPC 핸들러 구현과 동기화 상태를 유지해야 합니다.

---

### 파일 구성

#### 1. 핵심 타입 재내보내기

파일은 `core/types`에서 모든 것을 임포트하고 재내보내기로 시작합니다:

```typescript
import type {
  ItemParameter, ThetaEstimate, IRTModel,
  PMIResult, PMIPair, DifficultyMapping,
  // ... 모든 핵심 타입
} from '../core/types';

export type {
  ItemParameter, ThetaEstimate, IRTModel,
  // ... 렌더러 액세스를 위해 재내보내기
};
```

**재내보내기 이유**: 렌더러가 `core/`에서 직접 임포트할 수 없음 (다른 번들). 여기서 재내보내기함으로써 모든 타입에 대한 단일 임포트 경로를 만듭니다.

#### 2. IPC 채널 상수

```typescript
export const IPC_CHANNELS = {
  GOAL_CREATE: 'goal:create',
  GOAL_UPDATE: 'goal:update',
  // ... 50개 이상의 채널 상수
} as const;

export type IPCChannel = typeof IPC_CHANNELS[keyof typeof IPC_CHANNELS];
```

**목적**: 채널 이름에 대한 단일 진실 소스. `as const`는 TypeScript가 값을 리터럴 타입으로 취급하게 하여 완전한 타입 추론을 가능하게 합니다.

#### 3. IPC 요청/응답 타입

각 IPC 작업에 대해 요청 및 응답 형태를 정의합니다:

```typescript
// 목표 작업
export interface GoalCreateRequest {
  domain: string;
  modality: string[];
  genre: string;
  purpose: string;
  benchmark?: string;
  deadline?: string;
}

export interface GoalListResponse {
  goals: GoalSpec[];
  total: number;
}
```

#### 4. IPCHandlerMap

채널을 요청/응답 타입에 연결하는 마스터 타입 맵:

```typescript
export interface IPCHandlerMap {
  [IPC_CHANNELS.GOAL_CREATE]: {
    request: GoalCreateRequest;
    response: GoalSpec;
  };
  [IPC_CHANNELS.GOAL_LIST]: {
    request: GoalListRequest;
    response: GoalListResponse;
  };
  // ... 모든 채널
}
```

**사용 방법**:
```typescript
// contracts.ts에서
registerHandler<'goal:create'>('goal:create', async (event, request) => {
  // TypeScript 알음: request는 GoalCreateRequest
  // TypeScript 알음: IPCResponse<GoalSpec>를 반환해야 함
});
```

#### 5. 타입 헬퍼

맵에서 타입을 추출하기 위한 유틸리티:

```typescript
// 채널에 대한 요청 타입 가져오기
export type IPCRequest<T extends IPCChannel> =
  T extends keyof IPCHandlerMap ? IPCHandlerMap[T]['request'] : never;

// 채널에 대한 응답 타입 가져오기
export type IPCResponseData<T extends IPCChannel> =
  T extends keyof IPCHandlerMap ? IPCHandlerMap[T]['response'] : never;
```

#### 6. 프리로드 API 인터페이스

`window.logos` API를 위한 구조화된 인터페이스:

```typescript
export interface GoalAPI {
  create: (data: {...}) => Promise<GoalSpec>;
  get: (id: string) => Promise<GoalSpec | null>;
  list: (includeInactive?: boolean) => Promise<GoalSpec[]>;
  update: (data: {...}) => Promise<GoalSpec>;
  delete: (id: string, hard?: boolean) => Promise<void>;
}

export interface LogosAPI {
  goal: GoalAPI;
  object: ObjectAPI;
  session: SessionAPI;
  queue: QueueAPI;
  mastery: MasteryAPI;
  analytics: AnalyticsAPI;
  profile: ProfileAPI;
  claude: ClaudeAPI;
  corpus: CorpusAPI;
  sync: SyncAPI;
  onboarding: OnboardingAPI;
  app: AppAPI;
}
```

#### 7. 전역 Window 확장

TypeScript의 전역 Window 인터페이스 확장:

```typescript
declare global {
  interface Window {
    logos: LogosAPI;
  }
}
```

**전역 선언 이유**: 이것 없이는 TypeScript가 `window.logos`에서 속성이 존재하지 않는다고 오류. 이것은 TypeScript에게 "런타임에 이 속성이 존재할 것을 믿어라"라고 말합니다.

#### 8. 이벤트 타입

메인에서 렌더러로의 푸시 알림용:

```typescript
export const IPC_EVENTS = {
  SESSION_TASK_READY: 'event:session:task-ready',
  SYNC_COMPLETED: 'event:sync:completed',
  // ...
} as const;

export interface IPCEventPayloads {
  [IPC_EVENTS.SESSION_TASK_READY]: {
    sessionId: string;
    task: Task;
  };
  // ...
}
```

---

### 기술 개념 (평이한 설명)

#### 타입 맵 (IPCHandlerMap)

**기술적**: 키가 리터럴 채널 문자열이고 값이 요청 및 응답 타입을 포함하는 객체인 인덱스드 타입으로, 채널 이름을 기반으로 타입의 컴파일 타임 조회를 가능하게 합니다.

**평이한 설명**: 채널 이름을 조회하면 어떤 데이터를 보내고 어떤 데이터를 받을지 알려주는 "사전"입니다. TypeScript가 이 사전을 컴파일 타임에 사용하여 코드를 검사합니다.

**사용 이유**: `invoke('goal:create', data)`를 작성하면 TypeScript가 맵에서 'goal:create'를 조회하고 `data`가 `GoalCreateRequest`와 일치하는지, 응답을 `GoalSpec`으로 처리하는지 확인합니다.

#### 매핑된 타입 헬퍼 (Mapped Type Helpers)

**기술적**: `keyof`, `extends`, 조건부 타입을 사용하여 복잡한 타입 구조에서 특정 타입을 추출하는 유틸리티 타입.

**평이한 설명**: "이 채널의 요청 타입이 뭐야?" 또는 "이 채널의 응답 타입이 뭐야?"와 같은 질문에 답하는 작은 헬퍼 타입. 메인 맵에서 계산되므로 자동으로 동기화됩니다.

```typescript
type IPCRequest<'goal:create'> = GoalCreateRequest  // 맵에서 계산됨
```

#### 전역 선언 (Global Declaration)

**기술적**: `declare global { }`를 사용하여 실제 소스를 수정하지 않고 TypeScript의 내장 타입 정의를 확장합니다.

**평이한 설명**: TypeScript에게 "Window 타입에는 보통 `logos`가 없다는 거 알아, 하지만 런타임에는 존재할 거야"라고 말합니다. 이를 통해 TypeScript가 불평하지 않고 `window.logos`를 사용할 수 있습니다.

#### Const 어설션 (Const Assertion)

**기술적**: `as const` 어설션은 확장된 타입 대신 리터럴 타입이 있는 읽기 전용 타입을 만듭니다.

**평이한 설명**: 보통 `{ x: 'hello' }`는 `{ x: string }` 타입을 가집니다. `as const`를 사용하면 `{ readonly x: 'hello' }` 타입을 가집니다. 이 정밀도는 채널 이름으로 타입 추론이 올바르게 작동하는 데 필요합니다.

---

### 변경 이력

#### 2026-01-06 - 초기 문서화

- **변경 내용**: shared/types.ts에 대한 섀도우 문서 생성
- **이유**: 크로스 프로세스 타입 브릿지는 IPC 타이핑 이해를 위한 문서화 필요
- **영향**: 개발자와 AI 에이전트가 프로세스 경계를 넘는 타입 시스템을 이해할 수 있음

---

*이 문서는 `src/shared/types.ts`를 반영합니다*

---

## 9. IPC 요청/응답 스키마 (IPC Request/Response Schemas)

> **최종 업데이트**: 2026-01-06
> **코드 위치**: `src/shared/schemas/ipc-schemas.ts`
> **상태**: 활성

---

### 컨텍스트 및 목적 (Context & Purpose)

이 모듈은 Electron 렌더러 프로세스(사용자 인터페이스)와 메인 프로세스(비즈니스 로직과 데이터베이스 액세스가 일어나는 곳) 사이의 모든 통신에 대한 **런타임 유효성 검사 레이어**로 존재합니다. TypeScript가 컴파일 타임 타입 검사를 제공하지만, 런타임에 잘못된 데이터를 잡을 수 없습니다 - 그리고 Electron 앱에서 렌더러와 메인 프로세스는 본질적으로 직렬화된 데이터를 교환하는 별개의 프로그램입니다.

**비즈니스 요구사항**: 사용자는 복잡한 학습 기능(목표 생성, 응답 기록, 어휘 가져오기)과 상호작용합니다. 잘못된 데이터는 데이터베이스를 손상시키거나, 애플리케이션을 충돌시키거나, 잘못된 학습 추천을 생성할 수 있습니다. 이 모듈은 모든 IPC 요청이 처리 전에 엄격한 유효성 검사 규칙을 충족하도록 보장하여 "쓰레기가 들어가면 쓰레기가 나온다"를 방지합니다.

**사용 시점**: 렌더러에서 오는 모든 단일 IPC 호출이 이 스키마를 통과합니다. 사용자가 "세션 시작"을 클릭하거나, 어휘를 가져오거나, 응답을 기록하거나, 어떤 작업을 수행하든 - 메인 프로세스가 처리하기 전에 요청 데이터가 이 스키마에 대해 유효성 검사됩니다.

---

### 미시적 규모: 직접적 관계 (Microscale: Direct Relationships)

#### 의존성 (이것이 필요로 하는 것)

- `zod` (npm 패키지): 모든 유효성 검사기를 구동하는 런타임 스키마 유효성 검사 라이브러리. Zod는 유효성 검사기와 TypeScript 타입을 모두 생성하는 선언적 스키마 정의를 제공합니다.

#### 종속자 (이것을 필요로 하는 것)

- `src/main/ipc/learning.ipc.ts`: 데이터베이스 작업 전에 들어오는 요청을 유효성 검사하기 위해 `QueueGetSchema`, `ObjectCreateSchema`, `ObjectUpdateSchema`, `ObjectListSchema`, `ObjectImportSchema`, `ObjectSearchSchema`와 `validateInput` 헬퍼를 임포트하고 사용.

- `src/main/ipc/contracts.ts`: IPC 핸들러 인프라를 정의. 자체 간단한 유효성 검사기가 있지만 이 파일의 Zod 스키마가 더 나은 오류 메시지와 함께 더 강력한 유효성 검사를 제공.

- `src/main/preload.ts`: 렌더러에 API 노출 - 여기서 오는 요청이 이 스키마를 사용하는 핸들러를 통해 흐름.

#### 데이터 흐름

```
렌더러 UI (React)
    |
    | 사용자 동작이 API 호출 트리거
    v
preload.ts (contextBridge)
    |
    | ipcRenderer.invoke(channel, data)
    v
IPC 핸들러 (메인 프로세스)
    |
    | validateInput(Schema, data) <-- 이 파일
    |
    +--[유효하지 않음]--> 오류 응답 반환
    |
    +--[유효함]--> 비즈니스 로직으로 계속
```

---

### 거시적 규모: 시스템 통합 (Macroscale: System Integration)

#### 아키텍처 역할

이 모듈은 **IPC 경계 레이어**에 위치합니다 - 신뢰할 수 없는 렌더러 입력과 신뢰할 수 있는 메인 프로세스 작업 사이의 중요한 검문소입니다.

```
아키텍처 레이어:
-----------------------------------------
Layer 1: UI (React 컴포넌트)
    |
    v [IPC 호출]
-----------------------------------------
Layer 2: IPC 경계 (contextBridge + preload)
    |
    v [직렬화된 데이터]
-----------------------------------------
>>> Layer 3: 스키마 유효성 검사 (이 모듈) <<<
    |
    +--[유효하지 않음]--> 오류 응답
    |
    v [유효성 검사된 데이터]
-----------------------------------------
Layer 4: IPC 핸들러 (비즈니스 로직)
    |
    v [데이터베이스 작업]
-----------------------------------------
Layer 5: 데이터베이스 (Prisma + SQLite)
-----------------------------------------
```

#### 큰 그림의 영향

이 모듈 없이는 전체 애플리케이션의 데이터 무결성이 위험에 처합니다. 다음을 가능하게 합니다:

1. **안전한 데이터베이스 작업**: SQL 인젝션 유사 문제와 데이터 손상 방지
2. **의미 있는 오류 메시지**: 사용자가 불명확한 데이터베이스 오류 대신 "goalId는 유효한 UUID여야 합니다"를 봄
3. **타입 추론**: 내보내진 타입(`QueueGetRequest`, `ObjectCreateRequest` 등)이 런타임 유효성 검사기에서 직접 파생된 TypeScript 타입을 제공하여 타입/유효성 검사 드리프트 제거
4. **기본값**: 스키마 기본값(`sessionSize: 20`, `newItemRatio: 0.3` 등)이 선택적 필드가 생략되어도 일관된 동작 보장

#### 중요 경로 분석

**중요도 수준**: 중요

- **이것이 실패하면**: 잘못된 데이터가 데이터베이스 레이어에 도달하여 충돌, 손상된 학습 기록, 또는 잘못된 알고리즘 출력(나쁜 IRT 계산, 잘못된 스케줄링) 발생
- **보안 표면**: 렌더러의 잘못된 입력에 대한 첫 번째 방어선
- **성능**: Zod 유효성 검사는 빠름(유효성 검사당 <1ms), 하지만 모든 IPC 호출에서 실행 - 스키마를 효율적으로 유지하는 것이 중요

---

### 기술 개념 (평이한 설명)

#### Zod 스키마 유효성 검사

**기술적**: 자동 TypeScript 타입 추론과 함께 런타임 타입 검사를 제공하는 TypeScript 우선 스키마 선언 및 유효성 검사 라이브러리.

**평이한 설명**: 공항의 보안 검문소처럼 생각하세요. TypeScript는 "이 티켓에는 이름과 좌석 번호가 있어야 합니다"라고 말하는 예약 시스템과 같습니다. Zod는 게이트에서 티켓을 확인하는 실제 경비원입니다 - 누군가 제대로 보이는 티켓을 위조해도 Zod가 잡아냅니다. 구조만이 아닌 실제 값을 확인하기 때문입니다.

**사용 이유**: TypeScript 타입은 런타임에 지워지기 때문입니다. 데이터가 IPC 경계(렌더러에서 메인으로)를 넘을 때 TypeScript는 도움이 되지 않습니다 - 실제 런타임 검사가 필요합니다.

#### UUID 유효성 검사

**기술적**: 문자열이 UUID v4 형식(특정 버전 비트가 있는 8-4-4-4-12 16진수 문자 패턴)을 따르는지 유효성 검사합니다.

**평이한 설명**: 모든 학습 객체, 목표, 세션에는 주민등록번호와 같은 고유 ID가 있습니다. 이 유효성 검사기는 누군가 ID로 "hello"나 "12345"를 전달할 수 없도록 합니다 - 올바르게 형식화된 범용 고유 식별자여야 합니다.

**사용 이유**: ID는 데이터베이스 조회의 근간입니다. 잘못된 ID는 최선의 경우 "찾을 수 없음" 오류를, 최악의 경우 잘못된 레코드와 일치할 수 있습니다.

#### 비율 스키마 (0-1)

**기술적**: 숫자가 [0, 1] 간격 내에 있는지 유효성 검사하며, 일반적으로 확률이나 비율을 나타냅니다.

**평이한 설명**: 꺼짐(0)에서 최대(100%)까지만 가는 볼륨 슬라이더와 같습니다. 많은 학습 지표가 비율로 표현됩니다 - 정확도(0.85 = 85%), 난이도(0.7 = 70% 도전적), 언어에서의 항목 빈도. 이것은 아무도 150%나 -20%를 전달할 수 없도록 합니다.

**사용 이유**: IRT(Item Response Theory)와 FSRS(Free Spaced Repetition Scheduler) 알고리즘은 이 범위의 값을 기대합니다. 범위를 벗어난 값은 수학적으로 유효하지 않은 결과를 생성합니다.

#### 스키마 정제 (Schema Refinements)

**기술적**: Zod의 `.refine()` 메서드가 단순한 타입/범위 검사를 넘어서는 사용자 정의 유효성 검사 로직을 추가합니다.

**평이한 설명**: "ID 확인" 외에 특별한 지시가 있는 경비원과 같습니다. `ObjectUpdateSchema`는 정제를 사용하여 최소한 하나의 필드가 업데이트되고 있는지 확인합니다 - 그렇지 않으면 업데이트 호출의 의미가 무엇입니까?

**사용 이유**: 일부 유효성 검사는 단순한 타입 제약으로 표현할 수 없는 필드 간 로직이 필요합니다(예: "A가 제공되면 B도 제공되어야 함").

#### 스키마에서 타입 추론

**기술적**: `z.infer<typeof Schema>`를 사용하여 Zod 스키마에서 TypeScript 타입을 파생하여 런타임 유효성 검사와 컴파일 타임 타입이 동기화 상태를 유지하도록 합니다.

**평이한 설명**: 같은 규칙을 두 번 작성하는 대신(TypeScript용 한 번, 유효성 검사용 한 번), Zod에서 한 번 작성하고 TypeScript 타입을 자동으로 추출합니다. 스키마를 업데이트하면 타입도 업데이트됩니다 - 동기화가 어긋날 위험이 없습니다.

**사용 이유**: "코드가 컴파일되지만 유효성 검사가 거부한다" 또는 그 반대의 전체 버그 클래스를 제거합니다.

---

### 스키마 카테고리

#### 공통 유효성 검사기

여러 스키마에서 사용되는 재사용 가능한 빌딩 블록:
- `uuidSchema`: UUID v4 형식
- `positiveInt`: 양의 정수 (1, 2, 3...)
- `nonNegativeInt`: 0 또는 양수 (0, 1, 2...)
- `percentageSchema`: 0-100 범위
- `ratioSchema`: 0-1 범위
- `nonEmptyString`: 최소 한 문자가 있는 문자열

#### 학습 IPC 스키마

어휘/학습 객체 관리 처리:
- `QueueGetSchema`: 세션을 위한 학습 큐 구축
- `ObjectCreateSchema`: 새 어휘 항목 생성
- `ObjectUpdateSchema`: 기존 항목 수정
- `ObjectListSchema`: 페이지네이션이 있는 항목 목록
- `ObjectImportSchema`: 대량 가져오기 (1-10,000 항목)
- `ObjectSearchSchema`: 목표의 어휘 내 검색

#### 세션 IPC 스키마

학습 세션 수명주기 처리:
- `SessionStartSchema`: 학습/복습 세션 시작
- `SessionEndSchema`: 세션 완료
- `RecordResponseSchema`: 태스크에 대한 사용자 답변 기록
- `SessionSummarySchema`: 세션 통계 가져오기

#### 목표 IPC 스키마

학습 목표 관리 처리:
- `GoalCreateSchema`: 새 학습 목표 생성
- `GoalUpdateSchema`: 목표 설정 수정

#### 온보딩 IPC 스키마

새 사용자 설정 처리:
- `OnboardingCompleteSchema`: 온보딩 마법사 데이터 완료

#### Claude IPC 스키마

AI 기반 기능 처리:
- `ClaudeGenerateTaskSchema`: AI 생성 태스크 요청
- `ClaudeAnalyzeErrorSchema`: 사용자 오류 분석
- `ClaudeGetHintSchema`: 점진적 힌트 가져오기

---

### 변경 이력

#### 2026-01-06 - 문서 생성

- **변경 내용**: 이 모듈에 대한 초기 내러티브 문서
- **이유**: 섀도우 문서화 시스템 요구사항
- **영향**: 개발자가 이제 스키마 유효성 검사 레이어에 대한 컨텍스트를 가짐

#### 초기 구현

- **변경 내용**: 모든 IPC 채널에 대한 포괄적인 Zod 스키마 생성
- **이유**: 데이터 무결성을 보장하기 위해 Electron IPC 통신에 런타임 유효성 검사 필요
- **영향**: 모든 IPC 핸들러가 유효성 검사된 입력을 안전하게 가정할 수 있음; 사용자가 잘못된 요청에 대해 의미 있는 오류 메시지 받음

---

*이 문서는 `src/shared/schemas/ipc-schemas.ts`를 반영합니다*

